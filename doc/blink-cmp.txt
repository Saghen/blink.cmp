*blink-cmp.txt*         For NVIM v0.10.0         Last change: 2025 November 12

==============================================================================
Table of Contents                                *blink-cmp-table-of-contents*

1. Introduction                                       |blink-cmp-introduction|
  - Features                                 |blink-cmp-introduction-features|
  - Compared to built-in completion|blink-cmp-introduction-compared-to-built-in-completion|
  - Compared to nvim-cmp         |blink-cmp-introduction-compared-to-nvim-cmp|
  - Special Thanks                     |blink-cmp-introduction-special-thanks|
2. Installation                                       |blink-cmp-installation|
  - Requirements                         |blink-cmp-installation-requirements|
  - lazy.nvim                               |blink-cmp-installation-lazy.nvim|
  - mini.deps                               |blink-cmp-installation-mini.deps|
3. Recipes                                                 |blink-cmp-recipes|
  - General                                        |blink-cmp-recipes-general|
  - Fuzzy (sorting/filtering)    |blink-cmp-recipes-fuzzy-(sorting/filtering)|
  - Sources                                        |blink-cmp-recipes-sources|
  - Completion menu drawing        |blink-cmp-recipes-completion-menu-drawing|
  - For writers                                |blink-cmp-recipes-for-writers|
4. Config                                                   |blink-cmp-config|
  - General                                         |blink-cmp-config-general|
  - Appearance                                   |blink-cmp-config-appearance|
  - Completion                                   |blink-cmp-config-completion|
  - Fuzzy                                             |blink-cmp-config-fuzzy|
  - Keymap                                           |blink-cmp-config-keymap|
  - Signature                                     |blink-cmp-config-signature|
  - Snippets                                       |blink-cmp-config-snippets|
  - Sources                                         |blink-cmp-config-sources|
  - Reference                                     |blink-cmp-config-reference|
5. Modes                                                     |blink-cmp-modes|
  - Command line (cmdline)            |blink-cmp-modes-command-line-(cmdline)|
  - Terminal (term)                          |blink-cmp-modes-terminal-(term)|
6. Development                                         |blink-cmp-development|
  - Architecture                          |blink-cmp-development-architecture|
  - LSP Support Tracker            |blink-cmp-development-lsp-support-tracker|
  - Source Boilerplate              |blink-cmp-development-source-boilerplate|
7. Links                                                     |blink-cmp-links|

==============================================================================
1. Introduction                                       *blink-cmp-introduction*

**blink.cmp** is a completion plugin with support for LSPs, cmdline, signature
help and snippets. It uses an optional
<https://cmp.saghen.dev/configuration/fuzzy.html#rust-vs-lua-implementation>
custom fuzzy matcher <https://github.com/saghen/frizbee> for typo resistance.
It provides extensibility via pluggable sources (LSP, buffer, snippets, etc),
component based rendering and scripting for the configuration.


FEATURES                                     *blink-cmp-introduction-features*

- Works out of the box with no additional configuration
- Updates on every keystroke (0.5-4ms async, single core)
- Typo resistant fuzzy <https://github.com/saghen/frizbee> with frecency and proximity bonus
- Extensive LSP support (tracker </development/lsp-tracker>)
- Snippet support </configuration/snippets>: native `vim.snippet` (including `friendly-snippets`), `LuaSnip` and `mini.snippets`
- External sources support (community sources </configuration/sources#community-sources> and compatibility layer for `nvim-cmp` sources <https://github.com/saghen/blink.compat>)
- Auto-bracket support </configuration/completion#auto-brackets> based on semantic tokens
- Signature help </configuration/signature> (experimental, opt-in)
- Command line completion </modes/cmdline>
- Terminal completion </modes/term> (0.11+ only! No source for shell completions exists yet, contributions welcome!)


COMPARED TO BUILT-IN COMPLETION*blink-cmp-introduction-compared-to-built-in-completion*

- Typo resistant fuzzy matching
    - Smarter scoring <https://github.com/saghen/frizbee#algorithm>
    - Proximity + frecency score bonuses
- Prefetching to minimize LSP latency
- Support for external non-LSP sources </configuration/sources.html#community-sources> (snippets, path, buffer, git, ripgrep, …)
- Ghost text </configuration/completion.html#ghost-text>
- Automatic signature help </configuration/signature.html>
- Auto-bracket support </configuration/completion.html#auto-brackets> based on semantic tokens


COMPARED TO NVIM-CMP             *blink-cmp-introduction-compared-to-nvim-cmp*

- Avoids the complexity of nvim-cmp’s configuration by providing sensible defaults
- Updates on every keystroke with 0.5-4ms of overhead, versus nvim-cmp’s default debounce of 60ms with 2-50ms hitches from processing
    - You may try magazine.nvim <https://github.com/iguanacucumber/magazine.nvim> which includes many performance patches, some of which have been merged into nvim-cmp
- Boosts completion item score via frecency _and_ proximity bonus. nvim-cmp boosts score via proximity bonus and optionally by recency
- Typo-resistant fuzzy matching unlike nvim-cmp’s fzf-style fuzzy matching
- Core sources (buffer, snippets, path, lsp) are built-in versus nvim-cmp’s exclusively external sources
- Built-in auto bracket and signature help support
- Prefetching to minimize LSP latency


SPECIAL THANKS                         *blink-cmp-introduction-special-thanks*

- @hrsh7th <https://github.com/hrsh7th/> nvim-cmp used as inspiration and cmp-path/cmp-cmdline implementations modified for path/cmdline sources
- @garymjr <https://github.com/garymjr> nvim-snippets implementation modified for snippets source
- @redxtech <https://github.com/redxtech> Help with design and testing
- @aaditya-sahay <https://github.com/aaditya-sahay> Help with rust, design and testing


CONTRIBUTORS ~

- @stefanboca <https://github.com/stefanboca> Author of blink.compat <https://github.com/saghen/blink.compat>
- @lopi-py <https://github.com/lopi-py> Windowing code
- @scottmckendry <https://github.com/scottmckendry> CI and prebuilt binaries
- @balssh <https://github.com/Balssh> + @konradmalik <https://github.com/konradmalik> Nix flake, nixpkg and nixvim
- @abeldekat <https://github.com/abeldekat> mini.snippets source
- @wurli <https://github.com/wurli> Terminal completions
- @mikavilpas <https://github.com/mikavilpas> + @xzbdmw <https://github.com/xzbdmw> Dot-repeat (`.`)
- @soifou <https://github.com/soifou>
- @FerretDetective <https://github.com/FerretDetective> `complete_func` source
- @krovuxdev <https://github.com/krovuxdev> Community moderation and help


==============================================================================
2. Installation                                       *blink-cmp-installation*



REQUIREMENTS                             *blink-cmp-installation-requirements*

- Neovim 0.10+
- Using prebuilt binaries:
    - curl
    - git
- Building from source:
    - Rust nightly or rustup <https://rustup.rs/>

Note: By default, Blink will attempt to use the rust implementation of the
fuzzy matcher. However, the lua implementation does not require any of these
dependencies. See the fuzzy documentation <./configuration/fuzzy.md> for more
information.


LAZY.NVIM                                   *blink-cmp-installation-lazy.nvim*

>lua
    {
      'saghen/blink.cmp',
      -- optional: provides snippets for the snippet source
      dependencies = { 'rafamadriz/friendly-snippets' },
    
      -- use a release tag to download pre-built binaries
      version = '1.*',
      -- AND/OR build from source, requires nightly: https://rust-lang.github.io/rustup/concepts/channels.html#working-with-nightly-rust
      -- build = 'cargo build --release',
      -- If you use nix, you can build from source using latest nightly rust with:
      -- build = 'nix run .#build-plugin',
    
      ---@module 'blink.cmp'
      ---@type blink.cmp.Config
      opts = {
        -- 'default' (recommended) for mappings similar to built-in completions (C-y to accept)
        -- 'super-tab' for mappings similar to vscode (tab to accept)
        -- 'enter' for enter to accept
        -- 'none' for no mappings
        --
        -- All presets have the following mappings:
        -- C-space: Open menu or open docs if already open
        -- C-n/C-p or Up/Down: Select next/previous item
        -- C-e: Hide menu
        -- C-k: Toggle signature help (if signature.enabled = true)
        --
        -- See :h blink-cmp-config-keymap for defining your own keymap
        keymap = { preset = 'default' },
    
        appearance = {
          -- 'mono' (default) for 'Nerd Font Mono' or 'normal' for 'Nerd Font'
          -- Adjusts spacing to ensure icons are aligned
          nerd_font_variant = 'mono'
        },
    
        -- (Default) Only show the documentation popup when manually triggered
        completion = { documentation = { auto_show = false } },
    
        -- Default list of enabled providers defined so that you can extend it
        -- elsewhere in your config, without redefining it, due to `opts_extend`
        sources = {
          default = { 'lsp', 'path', 'snippets', 'buffer' },
        },
    
        -- (Default) Rust fuzzy matcher for typo resistance and significantly better performance
        -- You may use a lua implementation instead by using `implementation = "lua"` or fallback to the lua implementation,
        -- when the Rust fuzzy matcher is not available, by using `implementation = "prefer_rust"`
        --
        -- See the fuzzy documentation for more information
        fuzzy = { implementation = "prefer_rust_with_warning" }
      },
      opts_extend = { "sources.default" }
    }
<


LSP CAPABILITIES ~


LSP servers and clients communicate which features they support through
"capabilities". By default, Neovim supports a subset of the LSP specification.
With blink.cmp, Neovim has _more_ capabilities which are communicated to the
LSP servers.

Explanation from TJ: https://youtu.be/m8C0Cq9Uv9o?t=1275

This can vary by config, but in general for nvim-lspconfig:

>lua
    {
      'neovim/nvim-lspconfig',
      dependencies = { 'saghen/blink.cmp' },
    
      -- example using `opts` for defining servers
      opts = {
        servers = {
          lua_ls = {}
        }
      },
      config = function(_, opts)
        local lspconfig = require('lspconfig')
        for server, config in pairs(opts.servers) do
          -- passing config.capabilities to blink.cmp merges with the capabilities in your
          -- `opts[server].capabilities, if you've defined it
          config.capabilities = require('blink.cmp').get_lsp_capabilities(config.capabilities)
          lspconfig[server].setup(config)
        end
      end
    
     -- example calling setup directly for each LSP
      config = function()
        local capabilities = require('blink.cmp').get_lsp_capabilities()
        local lspconfig = require('lspconfig')
    
        lspconfig['lua_ls'].setup({ capabilities = capabilities })
      end
    }
<


MERGING LSP CAPABILITIES

Blink.cmp’s `get_lsp_capabilities` function includes the built-in LSP
capabilities by default. To merge with your own capabilities, use the first
argument, which acts as an override.

>lua
    local capabilities = {
      textDocument = {
        foldingRange = {
          dynamicRegistration = false,
          lineFoldingOnly = true
        }
      }
    }
    
    capabilities = require('blink.cmp').get_lsp_capabilities(capabilities)
    
    -- or equivalently
    
    local capabilities = vim.lsp.protocol.make_client_capabilities()
    
    capabilities = vim.tbl_deep_extend('force', capabilities, require('blink.cmp').get_lsp_capabilities({}, false))
    
    capabilities = vim.tbl_deep_extend('force', capabilities, {
      textDocument = {
        foldingRange = {
          dynamicRegistration = false,
          lineFoldingOnly = true
        }
      }
    })
<


MINI.DEPS                                   *blink-cmp-installation-mini.deps*

The following section includes only the installation and, optionally, building
of the fuzzy matcher. Check the |blink-cmp-lazy.nvim| section for recommended
configuration options and setting up `nvim-lspconfig`.

>lua
    -- use a release tag to download pre-built binaries
    MiniDeps.add({
      source = "saghen/blink.cmp",
      depends = { "rafamadriz/friendly-snippets" },
      checkout = "some.version", -- check releases for latest tag
    })
    
    -- OR build from source, requires nightly: https://rust-lang.github.io/rustup/concepts/channels.html#working-with-nightly-rust
    local function build_blink(params)
      vim.notify('Building blink.cmp', vim.log.levels.INFO)
      local obj = vim.system({ 'cargo', 'build', '--release' }, { cwd = params.path }):wait()
      if obj.code == 0 then
        vim.notify('Building blink.cmp done', vim.log.levels.INFO)
      else
        vim.notify('Building blink.cmp failed', vim.log.levels.ERROR)
      end
    end
    
    MiniDeps.add({
      source = 'Saghen/blink.cmp',
      hooks = {
        post_install = build_blink,
        post_checkout = build_blink,
      },
    })
<


==============================================================================
3. Recipes                                                 *blink-cmp-recipes*

Feel free to open a PR with any of your own recipes!

[[toc]]


GENERAL                                            *blink-cmp-recipes-general*


DISABLE PER FILETYPE/BUFFER ~

You may change the `enabled` function to return `false` for any case you’d
like to disable completion.

>lua
    enabled = function() return not vim.tbl_contains({ "lua", "markdown" }, vim.bo.filetype) end,
<

or set `vim.b.completion = false` on the buffer

>lua
    -- via an autocmd
    vim.api.nvim_create_autocmd('BufEnter', {
      pattern = '*.lua',
      callback = function()
        vim.b.completion = false
      end,
    })
    
    -- or via ftplugin/some-filetype.lua
    vim.b.completion = false
<


DISABLE COMPLETION IN ONLY SHELL COMMAND MODE ~

When inside of git bash or WSL on windows, you may experience a hang with shell
commands. The following disables cmdline completions only when running shell
commands (e.g. `[':!' , ':%!']`), but still allows completion in other command
modes (e.g. `[':' , ':help', '/' , '?']`).

>lua
    sources = {
      providers = {
        cmdline = {
          -- ignores cmdline completions when executing shell commands
          enabled = function()
            return vim.fn.getcmdtype() ~= ':' or not vim.fn.getcmdline():match("^[%%0-9,'<>%-]*!")
          end
        }
      }
    }
<


DISABLE OR DELAY AUTO-SHOWING COMPLETION MENU ~

You may disable the auto-show behavior of the menu, or delay it by a given
number of milliseconds, via the `completion.menu.auto_show` and
`completion.menu.auto_show_delay_ms` options.

>lua
    completion = {
      menu = {
        -- Disable automatically showing the menu while typing, instead press `<C-space>` (by default) to show it manually
        auto_show = false,
        -- or per filetype
        auto_show = function(ctx, items) return vim.bo.filetype == 'markdown' end,
    
        -- Delay before showing the completion menu while typing
        auto_show_delay_ms = 500,
        -- or per filetype
        auto_show_delay_ms = function(ctx, items) return vim.bo.filetype == 'markdown' and 1000 or 0 end,
      }
    }
<


EMACS BEHAVIOR ~

Full discussion: https://github.com/Saghen/blink.cmp/issues/1367

>lua
    local has_words_before = function()
      local col = vim.api.nvim_win_get_cursor(0)[2]
      if col == 0 then
        return false
      end
      local line = vim.api.nvim_get_current_line()
      return line:sub(col, col):match("%s") == nil
    end
    
    -- in your blink configuration
    keymap = {
      preset = 'none',
    
      -- If completion hasn't been triggered yet, insert the first suggestion; if it has, cycle to the next suggestion.
      ['<Tab>'] = {
        function(cmp)
          if has_words_before() then
            return cmp.insert_next()
          end
        end,
        'fallback',
      },
      -- Navigate to the previous suggestion or cancel completion if currently on the first one.
      ['<S-Tab>'] = { 'insert_prev' },
    },
    completion = {
      menu = { enabled = false },
      list = { selection = { preselect = false }, cycle = { from_top = false } },
    }
<


BORDER ~

On neovim 0.11+, you may use the `vim.o.winborder` option to set the default
border for all floating windows. You may override that option with your own
border value as shown below.

>lua
    completion = {
      menu = { border = 'single' },
      documentation = { window = { border = 'single' } },
    },
    signature = { window = { border = 'single' } },
<


SELECT NTH ITEM FROM THE LIST ~

Based on #382 <https://github.com/Saghen/blink.cmp/issues/382>

>lua
    keymap = {
      preset = 'default',
      ['<A-1>'] = { function(cmp) cmp.accept({ index = 1 }) end },
      ['<A-2>'] = { function(cmp) cmp.accept({ index = 2 }) end },
      ['<A-3>'] = { function(cmp) cmp.accept({ index = 3 }) end },
      ['<A-4>'] = { function(cmp) cmp.accept({ index = 4 }) end },
      ['<A-5>'] = { function(cmp) cmp.accept({ index = 5 }) end },
      ['<A-6>'] = { function(cmp) cmp.accept({ index = 6 }) end },
      ['<A-7>'] = { function(cmp) cmp.accept({ index = 7 }) end },
      ['<A-8>'] = { function(cmp) cmp.accept({ index = 8 }) end },
      ['<A-9>'] = { function(cmp) cmp.accept({ index = 9 }) end },
      ['<A-0>'] = { function(cmp) cmp.accept({ index = 10 }) end },
    },
    completion = {
      menu = {
        draw = {
          columns = { { 'item_idx' }, { 'kind_icon' }, { 'label', 'label_description', gap = 1 } },
          components = {
            item_idx = {
              text = function(ctx) return ctx.idx == 10 and '0' or ctx.idx >= 10 and ' ' or tostring(ctx.idx) end,
              highlight = 'BlinkCmpItemIdx' -- optional, only if you want to change its color
            }
          }
        }
      }
    }
<


HIDE COPILOT ON SUGGESTION ~

>lua
    vim.api.nvim_create_autocmd('User', {
      pattern = 'BlinkCmpMenuOpen',
      callback = function()
        require("copilot.suggestion").dismiss()
        vim.b.copilot_suggestion_hidden = true
      end,
    })
    
    vim.api.nvim_create_autocmd('User', {
      pattern = 'BlinkCmpMenuClose',
      callback = function()
        vim.b.copilot_suggestion_hidden = false
      end,
    })
<


AVOID MULTI-LINE COMPLETION GHOST TEXT ~

See nvim-cmp#1955
<https://github.com/hrsh7th/nvim-cmp/pull/1955#issue-2341857764> for an example
of what this looks like.

When ghost text is enabled (`completion.ghost_text.enabled = true`), you may
want the menu to avoid overlapping with the ghost text. You may provide a
custom `completion.menu.direction_priority` function to achieve this

>lua
    completion = {
      menu = {
        direction_priority = function()
          local ctx = require('blink.cmp').get_context()
          local item = require('blink.cmp').get_selected_item()
          if ctx == nil or item == nil then return { 's', 'n' } end
    
          local item_text = item.textEdit ~= nil and item.textEdit.newText or item.insertText or item.label
          local is_multi_line = item_text:find('\n') ~= nil
    
          -- after showing the menu upwards, we want to maintain that direction
          -- until we re-open the menu, so store the context id in a global variable
          if is_multi_line or vim.g.blink_cmp_upwards_ctx_id == ctx.id then
            vim.g.blink_cmp_upwards_ctx_id = ctx.id
            return { 'n', 's' }
          end
          return { 's', 'n' }
        end,
      },
    },
<


SHOW ON NEWLINE, TAB AND SPACE ~


Note that you may want to add the override to other sources as well, since if
the LSP doesn’t return any items, we won’t show the menu if it was
triggered by any of these three characters.

>lua
    -- by default, blink.cmp will block newline, tab and space trigger characters, disable that behavior
    completion.trigger.show_on_blocked_trigger_characters = {}
    
    -- add newline, tab and space to LSP source trigger characters
    sources.providers.lsp.override.get_trigger_characters = function(self)
      local trigger_characters = self:get_trigger_characters()
      vim.list_extend(trigger_characters, { '\n', '\t', ' ' })
      return trigger_characters
    end
<


FUZZY (SORTING/FILTERING)        *blink-cmp-recipes-fuzzy-(sorting/filtering)*

See the full docs <./configuration/fuzzy.md>


ALWAYS PRIORITIZE EXACT MATCHES ~

By default, the fuzzy matcher will give a bonus score of 4 to exact matches. If
you want to ensure that exact matches are always prioritized, you may set:

>lua
    fuzzy = {
      sorts = {
        'exact',
        -- defaults
        'score',
        'sort_text',
      },
    }
<


DEPRIORITIZE SPECIFIC LSP ~

You may use a custom sort function to deprioritize LSPs such as Emmet Language
Server (`emmet_ls`)

>lua
    fuzzy = {
      sorts = {
        function(a, b)
          if (a.client_name == nil or b.client_name == nil) or (a.client_name == b.client_name) then
            return
          end
          return b.client_name == 'emmet_ls'
        end,
        -- default sorts
        'score',
        'sort_text',
    }
<


EXCLUDE KEYWORDS/CONSTANTS FROM AUTOCOMPLETE ~

Removes language keywords/constants (if, else, while, etc.) provided by the
language server from completion results. Useful if you prefer to use builtin or
custom snippets for such constructs.

>lua
    sources = {
      providers = {
        lsp = {
          name = 'LSP',
          module = 'blink.cmp.sources.lsp',
          transform_items = function(_, items)
            return vim.tbl_filter(function(item)
              return item.kind ~= require('blink.cmp.types').CompletionItemKind.Keyword
            end, items)
          end,
        },
      },
    }
<


SOURCES                                            *blink-cmp-recipes-sources*

See the full docs <./configuration/sources.md>


BUFFER COMPLETION FROM ALL OPEN BUFFERS ~

The default behavior is to only show completions from **visible** "normal"
buffers (e.g. it wouldn’t include neo-tree). This will instead show
completions from all buffers, even if they’re not visible on screen. Note
that the performance impact of this has not been tested.

>lua
    sources = {
      providers = {
        buffer = {
          opts = {
            -- get all buffers, even ones like neo-tree
            get_bufnrs = vim.api.nvim_list_bufs
            -- or (recommended) filter to only "normal" buffers
            get_bufnrs = function()
              return vim.tbl_filter(function(bufnr)
                return vim.bo[bufnr].buftype == ''
              end, vim.api.nvim_list_bufs())
            end
          }
        }
      }
    }
<


DYNAMICALLY PICKING PROVIDERS BY TREESITTER NODE/FILETYPE ~

>lua
    sources.default = function(ctx)
      local success, node = pcall(vim.treesitter.get_node)
      if success and node and vim.tbl_contains({ 'comment', 'line_comment', 'block_comment' }, node:type()) then
        return { 'buffer' }
      elseif vim.bo.filetype == 'lua' then
        return { 'lsp', 'path' }
      else
        return { 'lsp', 'path', 'snippets', 'buffer' }
      end
    end
<


HIDE SNIPPETS AFTER TRIGGER CHARACTER ~

Trigger characters are defined by the sources. For example, for Lua, the
trigger characters are `.`, `"`, `'`.

>lua
    sources.providers.snippets.should_show_items = function(ctx)
      return ctx.trigger.initial_kind ~= 'trigger_character'
    end
<


SET SOURCE KIND ICON AND NAME ~

>lua
    sources.providers.copilot.transform_items = function(ctx, items)
      for _, item in ipairs(items) do
        item.kind_icon = ''
        item.kind_name = 'Copilot'
      end
      return items
    end
<


DISABLE ALL SNIPPETS ~

See the relevant section in the snippets documentation
<./configuration/snippets.md#disable-all-snippets>


SET MINIMUM KEYWORD LENGTH BY FILETYPE ~

>lua
    sources.min_keyword_length = function()
      return vim.bo.filetype == 'markdown' and 2 or 0
    end
<


PATH COMPLETION FROM CWD INSTEAD OF CURRENT BUFFER’S DIRECTORY ~

It’s common to run code from the root of your repository, in which case
relative paths will start from that directory. In that case, you may want path
completions to be relative to your current working directory rather than the
default, which is the current buffer’s parent directory.

>lua
    sources = {
      providers = {
        path = {
          opts = {
            get_cwd = function(_)
              return vim.fn.getcwd()
            end,
          },
        },
      },
    },
<

This also makes it easy to `:cwd` to the desired base directory for path
completion.


COMPLETION MENU DRAWING            *blink-cmp-recipes-completion-menu-drawing*

See the full docs <./configuration/completion.md#menu-draw>


KIND ICON BACKGROUND ~

You’ll need to configure your highlights (`BlinkCmpKind` or
`BlinkCmpKind<kind>`) to your desired background and foreground colors.

>lua
    completion = {
      menu = {
        draw = {
          padding = { 0, 1 }, -- padding only on right side
          components = {
            kind_icon = {
              text = function(ctx) return ' ' .. ctx.kind_icon .. ctx.icon_gap .. ' ' end
            }
          }
        }
      }
    }
<


MINI.ICONS ~

Original discussion <https://github.com/Saghen/blink.cmp/discussions/458>

>lua
    completion = {
      menu = {
        draw = {
          components = {
            kind_icon = {
              text = function(ctx)
                local kind_icon, _, _ = require('mini.icons').get('lsp', ctx.kind)
                return kind_icon
              end,
              -- (optional) use highlights from mini.icons
              highlight = function(ctx)
                local _, hl, _ = require('mini.icons').get('lsp', ctx.kind)
                return hl
              end,
            },
            kind = {
              -- (optional) use highlights from mini.icons
              highlight = function(ctx)
                local _, hl, _ = require('mini.icons').get('lsp', ctx.kind)
                return hl
              end,
            }
          }
        }
      }
    }
<


NVIM-WEB-DEVICONS + LSPKIND ~

Original discussion <https://github.com/Saghen/blink.cmp/discussions/1146>

>lua
    completion = {
      menu = {
        draw = {
          components = {
            kind_icon = {
              text = function(ctx)
                local icon = ctx.kind_icon
                if vim.tbl_contains({ "Path" }, ctx.source_name) then
                    local dev_icon, _ = require("nvim-web-devicons").get_icon(ctx.label)
                    if dev_icon then
                        icon = dev_icon
                    end
                else
                    icon = require("lspkind").symbolic(ctx.kind, {
                        mode = "symbol",
                    })
                end
    
                return icon .. ctx.icon_gap
              end,
    
              -- Optionally, use the highlight groups from nvim-web-devicons
              -- You can also add the same function for `kind.highlight` if you want to
              -- keep the highlight groups in sync with the icons.
              highlight = function(ctx)
                local hl = ctx.kind_hl
                if vim.tbl_contains({ "Path" }, ctx.source_name) then
                  local dev_icon, dev_hl = require("nvim-web-devicons").get_icon(ctx.label)
                  if dev_icon then
                    hl = dev_hl
                  end
                end
                return hl
              end,
            }
          }
        }
      }
    }
<


MINI.ICONS + LSPKIND ~

Uses mini.icons <https://github.com/echasnovski/mini.icons> to display icons
for filetypes and lspkind <https://github.com/onsails/lspkind-nvim> for LSP
kinds.

>lua
    completion = {
      menu = {
        draw = {
          components = {
            kind_icon = {
              text = function(ctx)
                if ctx.source_name ~= "Path" then
                  return require("lspkind").symbolic(ctx.kind, { mode = "symbol" }) .. ctx.icon_gap
                end
    
                local is_unknown_type = vim.tbl_contains({ "link", "socket", "fifo", "char", "block", "unknown" }, ctx.item.data.type)
                local mini_icon, _ = require("mini.icons").get(
                  is_unknown_type and "os" or ctx.item.data.type,
                  is_unknown_type and "" or ctx.label
                )
    
                return (mini_icon or ctx.kind_icon) .. ctx.icon_gap
              end,
    
              highlight = function(ctx)
                if ctx.source_name ~= "Path" then return ctx.kind_hl end
    
                local is_unknown_type = vim.tbl_contains({ "link", "socket", "fifo", "char", "block", "unknown" }, ctx.item.data.type)
                local mini_icon, mini_hl = require("mini.icons").get(
                  is_unknown_type and "os" or ctx.item.data.type,
                  is_unknown_type and "" or ctx.label
                )
                return mini_icon ~= nil and mini_hl or ctx.kind_hl
              end,
            }
          }
        }
      }
    }
<


FOR WRITERS                                    *blink-cmp-recipes-for-writers*

When writing prose, you may want significantly different behavior than typical
LSP completions. If you find any interesting configurations, please open a PR
adding it here!


KEEP FIRST LETTER CAPITALIZATION ON BUFFER SOURCE ~

>lua
    sources = {
      providers = {
        buffer = {
          -- keep case of first char
          transform_items = function (a, items)
            local keyword = a.get_keyword()
            local correct, case
            if keyword:match('^%l') then
                correct = '^%u%l+$'
                case = string.lower
            elseif keyword:match('^%u') then
                correct = '^%l+$'
                case = string.upper
            else
                return items
            end
    
            -- avoid duplicates from the corrections
            local seen = {}
            local out = {}
            for _, item in ipairs(items) do
                local raw = item.insertText
                if raw:match(correct) then
                    local text = case(raw:sub(1,1)) .. raw:sub(2)
                    item.insertText = text
                    item.label = text
                end
                if not seen[item.insertText] then
                    seen[item.insertText] = true
                    table.insert(out, item)
                end
            end
            return out
          end
        }
      }
    }
<


==============================================================================
4. Config                                                   *blink-cmp-config*


GENERAL                                             *blink-cmp-config-general*

Blink cmp has _a lot_ of configuration options, the following code block
highlights some changes you’re most likely to care about. For more
information, check out the additional pages.

For more common configurations, see the recipes <../recipes.md>.


>lua
    {
      -- Enables keymaps, completions and signature help when true (doesn't apply to cmdline or term)
      --
      -- If the function returns 'force', the default conditions for disabling the plugin will be ignored
      -- Default conditions: (vim.bo.buftype ~= 'prompt' and vim.b.completion ~= false)
      -- Note that the default conditions are ignored when `vim.b.completion` is explicitly set to `true`
      --
      -- Exceptions: vim.bo.filetype == 'dap-repl'
      enabled = function() return not vim.tbl_contains({ "lua", "markdown" }, vim.bo.filetype) end,
    
      -- Disable cmdline
      cmdline = { enabled = false },
    
      completion = {
        -- 'prefix' will fuzzy match on the text before the cursor
        -- 'full' will fuzzy match on the text before _and_ after the cursor
        -- example: 'foo_|_bar' will match 'foo_' for 'prefix' and 'foo__bar' for 'full'
        keyword = { range = 'full' },
    
        -- Disable auto brackets
        -- NOTE: some LSPs may add auto brackets themselves anyway
        accept = { auto_brackets = { enabled = false }, },
    
        -- Don't select by default, auto insert on selection
        list = { selection = { preselect = false, auto_insert = true } },
        -- or set via a function
        list = { selection = { preselect = function(ctx) return vim.bo.filetype ~= 'markdown' end } },
    
        menu = {
          -- Don't automatically show the completion menu
          auto_show = false,
    
          -- nvim-cmp style menu
          draw = {
            columns = {
              { "label", "label_description", gap = 1 },
              { "kind_icon", "kind" }
            },
          }
        },
    
        -- Show documentation when selecting a completion item
        documentation = { auto_show = true, auto_show_delay_ms = 500 },
    
        -- Display a preview of the selected item on the current line
        ghost_text = { enabled = true },
      },
    
      sources = {
        -- Remove 'buffer' if you don't want text completions, by default it's only enabled when LSP returns no items
        default = { 'lsp', 'path', 'snippets', 'buffer' },
      },
    
      -- Use a preset for snippets, check the snippets documentation for more information
      snippets = { preset = 'default' | 'luasnip' | 'mini_snippets' | 'vsnip' },
    
      -- Experimental signature help support
      signature = { enabled = true }
    }
<


APPEARANCE                                       *blink-cmp-config-appearance*

If you’re looking for how to change the appearance of the completion menu,
check out the menu draw configuration <./completion#menu-draw>.


HIGHLIGHT GROUPS ~

  ------------------------------------------------------------------------------------------------------
  Group                                  Default                       Description
  -------------------------------------- ----------------------------- ---------------------------------
  BlinkCmpMenu                           Pmenu                         The completion menu window

  BlinkCmpMenuBorder                     Pmenu                         The completion menu window border

  BlinkCmpMenuSelection                  PmenuSel                      The completion menu window
                                                                       selected item

  BlinkCmpScrollBarThumb                 PmenuThumb                    The scrollbar thumb

  BlinkCmpScrollBarGutter                PmenuSbar                     The scrollbar gutter

  BlinkCmpLabel                          Pmenu                         Label of the completion item

  BlinkCmpLabelDeprecated                PmenuExtra                    Deprecated label of the
                                                                       completion item

  BlinkCmpLabelMatch                     Pmenu                         (Currently unused) Label of the
                                                                       completion item when it matches
                                                                       the query

  BlinkCmpLabelDetail                    PmenuExtra                    Label description of the
                                                                       completion item

  BlinkCmpLabelDescription               PmenuExtra                    Label description of the
                                                                       completion item

  BlinkCmpKind                           PmenuKind                     Kind icon/text of the completion
                                                                       item

  BlinkCmpKind<kind>                     PmenuKind                     Kind icon/text of the completion
                                                                       item

  BlinkCmpSource                         PmenuExtra                    Source of the completion item

  BlinkCmpGhostText                      NonText                       Preview item with ghost text

  BlinkCmpDoc                            NormalFloat                   The documentation window

  BlinkCmpDocBorder                      NormalFloat                   The documentation window border

  BlinkCmpDocSeparator                   NormalFloat                   The documentation separator
                                                                       between doc and detail

  BlinkCmpDocCursorLine                  Visual                        The documentation window cursor
                                                                       line

  BlinkCmpSignatureHelp                  NormalFloat                   The signature help window

  BlinkCmpSignatureHelpBorder            NormalFloat                   The signature help window border

  BlinkCmpSignatureHelpActiveParameter   LspSignatureActiveParameter   Active parameter of the signature
                                                                       help
  ------------------------------------------------------------------------------------------------------

COMPLETION                                       *blink-cmp-config-completion*

Blink cmp has _a lot_ of configuration options, the following document tries to
highlight the ones you’ll likely care the most about for each section. For
all options, click on the "Go to default configuration" button next to each
header.

The online documentation contains images and videos for each section. You may
have a better experience viewing the docs on that website:
https://cmp.saghen.dev/configuration/completion


KEYWORD  ~

Controls what the plugin considers to be a keyword, used for fuzzy matching and
triggering completions. Most notably, the `range` option controls whether the
keyword should match against the text before _and_ after the cursor, or just
before the cursor.


>lua
    -- 'prefix' will fuzzy match on the text before the cursor
    -- 'full' will fuzzy match on the text before _and_ after the cursor
    -- example: 'foo_|_bar' will match 'foo_' for 'prefix' and 'foo__bar' for 'full'
    completion.keyword.range = 'prefix' | 'full'
<


TRIGGER  ~

Controls when to request completion items from the sources and show the
completion menu. The following options are available, excluding their `show_on`
prefix:



KEYWORD ~

Shows after typing a keyword, typically an alphanumeric character, `-` or `_`

>lua
    completion.trigger.show_on_keyword = true
<

Video:
https://github.com/user-attachments/assets/5e8f8f9f-bc6a-4d21-9cce-2e291b6a7de8


TRIGGER CHARACTER ~

Shows after typing a trigger character, defined by the sources. For example for
Lua or Rust, the LSP will define `.` as a trigger character.

>lua
    completion.trigger.show_on_trigger_character = true
    -- Optionally, set a list of characters that will not trigger the completion window,
    -- even when sources request it. The following are the defaults:
    completion.trigger.show_on_blocked_trigger_characters = { ' ', '\n', '\t' }
<

Video:
https://github.com/user-attachments/assets/b4ee0069-2de8-44e7-b3ca-51b10bc4cb4a


INSERT ON TRIGGER CHARACTER ~

Shows after entering insert mode on top of a trigger character.

>lua
    completion.trigger.show_on_insert_on_trigger_character = true
    -- Optionally, set a list of characters that will not trigger the completion window,
    -- even when sources request it. The following are the defaults:
    completion.trigger.show_on_x_blocked_trigger_characters = { "'", '"', '(', '{', '[' }
<

Video:
https://github.com/user-attachments/assets/9e7aa3c2-4756-4a5e-a0e8-303d3ae0fda9


ACCEPT ON TRIGGER CHARACTER ~

Shows after accepting a completion item, where the cursor ends up on top of a
trigger character.

>lua
    completion.trigger.show_on_accept_on_trigger_character = true
    -- Optionally, set a list of characters that will not trigger the completion window,
    -- even when sources request it. The following are the defaults:
    completion.trigger.show_on_x_blocked_trigger_characters = { "'", '"', '(', '{', '[' }
<


LIST  ~

Manages the completion list and its behavior when selecting items. The most
commonly changed option is `selection.preselect/auto_insert`, which controls
whether the list will automatically select the first item in the list, and
whether a "preview" will be inserted on selection.




PRESELECT, AUTO INSERT (DEFAULT) ~

>lua
    completion.list.selection = { preselect = true, auto_insert = true }
<

Selects the first item automatically, and inserts a preview of the item on
selection. The `cancel` keymap (default `<C-e>`) will close the menu and undo
the preview.

You may use the `show_and_insert` keymap to show the completion menu and select
the first item, with `auto_insert`. The default keymap (`<C-space>`) uses the
`show` command, which will have the first item selected, but will not
`auto_insert`.

Video:
https://github.com/user-attachments/assets/ef295526-8332-4ad0-9a2a-e2f6484081b2


PRESELECT ~

>lua
    completion.list.selection = { preselect = true, auto_insert = false }
<

Selects the first item automatically

Video:
https://github.com/user-attachments/assets/69079ced-43f1-437e-8a45-3cb13f841d61


MANUAL ~

>lua
    completion.list.selection = { preselect = false, auto_insert = false }
<

No item will be selected by default. You may use the `select_and_accept` keymap
command to select the first item and accept it when there’s no selection. The
`accept` keymap command, on the other hand, will only trigger if an item is
selected.

You may use the `show_and_insert` keymap to show the completion menu and select
the first item. The default keymap (`<C-space>`) uses the `show` command, which
will not select the first item.

Video:
https://github.com/user-attachments/assets/09cd9b4b-18b3-456b-bb0a-074ae54e9d77


MANUAL, AUTO INSERT ~

>lua
    completion.list.selection = { preselect = false, auto_insert = true }
<

Selecting an item will insert a "preview" of the item automatically. You may
use the `select_and_accept` keymap command to select the first item and accept
it when there’s no selection. The `accept` keymap command will only trigger
if an item is selected. The `cancel` keymap (default `<C-e>`) will close the
menu and undo the preview.

You may use the `show_and_insert` keymap to show the completion menu and select
the first item, with `auto_insert`. The default keymap (`<C-space>`) uses the
`show` command, which will not select the first item.

Video:
https://github.com/user-attachments/assets/4658b61d-1b95-404a-b6b5-3a4afbfb8112

To control the selection behavior dynamically, pass a function to
`selection.preselect/auto_insert`:

>lua
    completion.list.selection = {
      preselect = true,
      auto_insert = true,
    
      -- or a function
      preselect = function(ctx)
        return not require('blink.cmp').snippet_active({ direction = 1 })
      end,
      auto_insert = function(ctx) return vim.bo.filetype ~= 'markdown' end,
    }
<


ACCEPT  ~

Manages the behavior when accepting an item in the completion menu.


AUTO BRACKETS


LSPs provide a `kind` field for completion items, indicating whether the item
is a function, method, variable, etc. The plugin will automatically add
brackets for functions/methods and place the cursor inside the brackets. For
items not marked as such, the plugin will asynchronously resolve the semantic
tokens from the LSP and add brackets if marked as a function. A default list of
brackets have been included in the default configuration, but you may add more
in the configuration (contributions welcome!).

If brackets are showing when you don’t expect them, try disabling
`kind_resolution` or `semantic_token_resolution` for that filetype (`echo
&filetype`). If that fixes the issue, please open a PR setting this as the
default!


MENU  ~

Manages the appearance of the completion menu. You may prevent the menu from
automatically showing by setting `completion.menu.auto_show = false` and
manually showing it with the `show` keymap command.


MENU DRAW 

Check out the recipes! <../recipes.md#completion-menu-drawing>

blink.cmp uses a grid-based layout to render the completion menu. The
components, defined in `draw.components[string]`, define `text` and `highlight`
functions which are called for each completion item. The `highlight` function
will be called only when the item appears on screen, so expensive operations
such as Treesitter highlighting may be performed. The components may define
their min and max width, where `ellipsis = true` (enabled by default), will
draw the `…` character when the text is truncated. Setting `width.fill =
true` will fill the remaining space, effectively making subsequent components
right aligned, with respect to their column.

Columns effectively allow you to vertically align a set of components. Each
column, defined as an array in `draw.columns`, will be rendered for all of the
completion items, where the longest rendered row will determine the width of
the column. You may define `gap = number` in your column to insert a gap
between components.

For a setup similar to nvim-cmp, use the following config:

>lua
    completion.menu.draw.columns = { { "label", "label_description", gap = 1 }, { "kind_icon", "kind" } },
<


AVAILABLE COMPONENTS

- `kind_icon`: Shows the icon for the kind of the item
- `kind`: Shows the kind of the item as text (e.g. `Function`)
- `label`: Shows the label of the item as well as the `label_detail` (e.g. `into(as Into)` where `into` is the label and `(as Into)` is the label detail)
    - If the `label_detail` is missing from your items, ensure you’ve setup LSP capabilities <../installation> and that your LSP supports the feature
- `label_description`: Shows the label description of the item (e.g. `date-fns/formatDistance`, the module that the item will be auto-imported from)
    - If the `label_description` is missing from your items, ensure you’ve setup LSP capabilities <../installation> and that your LSP supports the feature
- `source_name`: Shows the name of the source that provided the item, from the `sources.providers.*.name` (e.g. `LSP`)
- `source_id`: Shows the id of the source that provided the item, from the `sources.providers[id]` (e.g. `lsp`)


CURSORLINE

The cursorline background will be rendered with a priority of `10000` to ensure
that highlights with backgrounds (such as those from the default theme) will be
overridden by the cursorline. If you’d like to use a background in your
highlight, set the priority to `10001` or higher.

>lua
    completion.menu.draw.components.label.kind_icon.highlight = function(ctx)
      return { { group = ctx.kind_hl, priority = 20000 } }
    end
<

Or you may set the cursorline highlight priority to `0`

>lua
    completion.menu.draw.cursorline_priority = 0
<


TREESITTER

You may use treesitter to highlight the label text for the given list of
sources. This feature is barebones, as it highlights the item as-is.

>lua
    completion.menu.draw.treesitter = { 'lsp' }
<

The wonderful colorful-menu.nvim <https://github.com/xzbdmw/colorful-menu.nvim>
takes this a step further by including context around the item before
highlighting.


DOCUMENTATION  ~

By default, the documentation window will only show when triggered by the
`show_documentation` keymap command. However, you may add the following
configuration to show the documentation whenever an item is selected.

>lua
    completion.documentation = {
      auto_show = true,
      auto_show_delay_ms = 500,
    }
<

If you’re noticing high CPU usage or stuttering when opening the
documentation, you may try setting
`completion.documentation.treesitter_highlighting = false`. You may completely
override the drawing of the window via `completion.documentation.draw`.


GHOST TEXT  ~

Ghost text shows a preview of the currently selected item as virtual text
inline. You may want to try setting `completion.menu.auto_show = false` and
enabling ghost text, or you may use both in parallel.

>lua
    completion.ghost_text.enabled = true
    
    -- you may want to set the following options
    completion.menu.auto_show = false -- only show menu on manual <C-space>
    completion.ghost_text.show_with_menu = false -- only show when menu is closed
<




FUZZY                                                 *blink-cmp-config-fuzzy*

Blink uses a SIMD fuzzy matcher called frizbee
<https://github.com/saghen/frizbee> which achieves ~6x the performance of fzf
while ignoring typos. Check out the repo for more information!


RUST VS LUA IMPLEMENTATION ~

Prebuilt binaries are included in the releases and automatically downloaded
when on a release tag (see below). However, for unsupported systems or when the
download fails, it will automatically fallback to a Lua implementation,
emitting a warning. You may suppress this warning or enforce the Lua or Rust
implementation.

- `prefer_rust_with_warning` If available, use the Rust implementation, automatically downloading prebuilt binaries on supported systems. Fallback to the Lua implementation when not available, emitting a warning message.
- `prefer_rust`: If available, use the Rust implementation, automatically downloading prebuilt binaries on supported systems. Fallback to the Lua implementation when not available.
- `rust`: Always use the Rust implementation, automatically downloading prebuilt binaries on supported systems. Error if not available.
- `lua`: Always use the Lua implementation

>lua
    fuzzy = { implementation = "prefer_rust_with_warning" }
<


ADVANTAGES OF RUST IMPLEMENTATION

If possible, it’s highly recommended to use the Rust implementation of the
fuzzy matcher!

- Full unicode support
- Always finds the best match (resulting in better sorting)
- Performance on long lists (10k+ items)
- Typo resistance
- Proximity bonus
- Frecency


INSTALLATION ~


PREBUILT BINARIES (DEFAULT ON A RELEASE TAG)

By default, Blink will download a prebuilt binary from the latest release, when
you’re on a release tag (via `version = '1.*'` on `lazy.nvim` for example).
If you’re not on a release tag, you may force a specific version via
`fuzzy.prebuilt_binaries.force_version`. See the latest release
<https://github.com/saghen/blink.cmp/releases/latest> for supported systems.
See `prebuilt_binaries` section of the reference configuration
<./reference.md#fuzzy> for more options.

You may instead install the prebuilt binaries manually by downloading the
appropriate binary from the latest release
<https://github.com/saghen/blink.cmp/releases/latest> and placing it at
`$data/lazy/blink.cmp/target/release/libblink_cmp_fuzzy.$ext`. Get the `$data`
path via `:echo stdpath('data')`. Use `.so` for linux, `.dylib` for mac, and
`.dll` for windows. If you’re unsure whether you want `-musl` or `-gnu` for
linux, you very likely want `-gnu`.


  [!IMPORTANT] For the version verification to succeed, you must either ensure
  there is no `version` file adjacent to your `libblink_cmp_fuzzy` library or you
  must have `git` installed with the `.git` folder present in the `blink.cmp`
  directory
>sh
    # Linux
    ~/.local/share/nvim/lazy/blink.cmp/target/release/libblink_cmp_fuzzy.so
    
    # Mac
    ~/.local/share/nvim/lazy/blink.cmp/target/release/libblink_cmp_fuzzy.dylib
    
    # Windows
    ~/Appdata/Local/nvim/lazy/blink.cmp/target/release/libblink_cmp_fuzzy.dll
<


BUILD FROM SOURCE (RECOMMENDED FOR MAIN)

When on `main`, it’s highly recommended to build from source via `cargo build
--release` (via `build = '...'` on `lazy.nvim` for example). This requires a
nightly rust toolchain, which will be automatically downloaded when using
`rustup`.

You may also build with nix via `nix run .#build-plugin`.


CONFIGURATION ~

See the fuzzy section of the reference configuration <./reference.md#fuzzy>.
For recipes, see the recipes section <../recipes.md#fuzzy-sorting-filtering>.


SORTING

You can control how entries are sorted by choosing from several built-in
sorting methods or by providing your own custom Lua function.


BUILT-IN SORTS

The following built-in sort strings are available:

- `exact`: Sorts by exact match, case-sensitive
- `score`: Sorts by the fuzzy matching score
- `sort_text`: Sorts by the `sortText` field
    - Generally, this field provides better sorting than `label` as the source/LSP may prioritize items relevant to the current context
    - If you’re writing your own source, use this field to control sort order, instead of requiring users to add a sort function
- `label`: Sorts by the `label` field, deprioritizing entries with a leading `_`
- `kind`: Sorts by the numeric `kind` field
    - Check the order via `:lua vim.print(vim.lsp.protocol.CompletionItemKind)`


SORTING PRIORITY AND TIE-BREAKING

**The order in which you specify sorts in your configuration determines their
priority.**

When sorting, each entry pair is compared using the first method in your list.
If that comparison results in a tie, the next method is used, and so on. This
allows you to build multi-level sorting logic.

>lua
    fuzzy = {
      sorts = {
        'score',      -- Primary sort: by fuzzy matching score
        'sort_text',  -- Secondary sort: by sortText field if scores are equal
        'label',      -- Tertiary sort: by label if still tied
      }
    }
<

In the example above:

- Entries are first sorted by score.
- If two entries have the same score, they are then sorted by sort_text.
- If still tied, they are sorted by label.


SORT LIST FUNCTION

Instead of specifying a static list, you may also provide a function that
returns a list of sorts.

>lua
    fuzzy = {
      sorts = function()
        if vim.bo.filetype == "lua" then
          return { 'score', 'label' }  -- Prioritize label sorting for Lua files
        else
          return { 'score', 'sort_text', 'label' }  -- Default sorting for other filetypes
        end
      end,
    }
<


CUSTOM SORTING

You may also provide a custom Lua function to define your own sorting logic.
The function should follow the Lua table.sort
<https://www.lua.org/manual/5.1/manual.html#pdf-table.sort> convention.

>lua
    fuzzy = {
      sorts = {
        -- example custom sorting function, ensuring `_` entries are always last (untested, YMMV)
        function(a, b)
            if a.label:sub(1, 1) == "_" ~= a.label:sub(1, 1) == "_" then
                -- return true to sort `a` after `b`, and vice versa
                return not a.label:sub(1, 1) == "_"
            end
            -- nothing returned, fallback to the next sort
        end,
        -- default sorts
        'score',
        'sort_text',
    }
<

In the example above:

- The custom function is the primary sort: it puts entries starting with _ last.
- If two entries are equal according to the custom function, they are then sorted by score.
- If still tied, they are sorted by sort_text.



KEYMAP                                               *blink-cmp-config-keymap*

Blink uses a special schema for defining keymaps since it needs to handle
falling back to other mappings. However, there’s nothing stopping you from
using `require('blink.cmp')` and implementing these keymaps yourself.

Your custom key mappings are merged with a `preset` and any conflicting keys
will overwrite the preset mappings. The `fallback` command will run the next
non blink keymap.


EXAMPLE ~


Each keymap may be a list of commands and/or functions, where commands map
directly to `require('blink.cmp')[command]()`. If the command/function returns
`false` or `nil`, the next command/function will be run.

>lua
    keymap = {
      -- set to 'none' to disable the 'default' preset
      preset = 'default',
    
      ['<Up>'] = { 'select_prev', 'fallback' },
      ['<Down>'] = { 'select_next', 'fallback' },
    
      -- disable a keymap from the preset
      ['<C-e>'] = false, -- or {}
      
      -- show with a list of providers
      ['<C-space>'] = { function(cmp) cmp.show({ providers = { 'snippets' } }) end },
    
      -- control whether the next command will be run when using a function
      ['<C-n>'] = { 
        function(cmp)
          if some_condition then return end -- runs the next command
          if some_other_condition then return "a" end -- simulate keypresses, doesn't run the next command
          return true -- doesn't run the next command
        end,
        'select_next'
      },
    }
<


COMMANDS ~

- `show`: Shows the completion menu
    - Optionally use `function(cmp) cmp.show({ providers = { 'snippets' } }) end` to show with a specific list of providers
- `show_and_insert`: Shows the completion menu and inserts the first item
    - Short form for `cmp.show({ initial_selected_item_idx = 1 })` when `auto_insert = true`
- `show_and_insert_or_accept_single`: Shows the completion menu and inserts the first item, or accepts the first item if there is only one
- `hide`: Hides the completion menu
- `cancel`: Reverts `completion.list.selection.auto_insert` and hides the completion menu
- `accept`: Accepts the currently selected item
    - Optionally pass an index to select a specific item in the list: `function(cmp) cmp.accept({ index = 1 }) end`
    - Optionally pass a `callback` to run after the item is accepted: `function(cmp) cmp.accept({ callback = function() some_function() end`
- `accept_and_enter`: Accepts the currently selected item and feeds an enter key to neovim
    - Useful in `cmdline` mode to accept the current item and run the command
- `select_and_accept`: Accepts the currently selected item, or the first item if none are selected
- `select_accept_and_enter`: Accepts the currently selected item, or the first item if none are selected, and feeds an enter key to neovim
    - Useful in `cmdline` mode to accept the current item and run the command
- `select_prev`: Selects the previous item, cycling to the bottom of the list if at the top, if `completion.list.cycle.from_top == true`
    - Optionally, set the number of items to jump by, defaults to 1: `function(cmp) return cmp.select_prev({ count = 5 }) end`
    - Optionally, control the `auto_insert` property of `completion.list.selection`: `function(cmp) cmp.select_prev({ auto_insert = false }) end`
    - Optionally, run when ghost text is visible, instead of only when the menu is visible: `function(cmp) cmp.select_prev({ on_ghost_text = true })`
    - Optionally, jump to the item whose specified property differs from the current one: `function(cmp) cmp.select_prev({ jump_by = 'source_id' })`
- `select_next`: Selects the next item, cycling to the top of the list if at the bottom, if `completion.list.cycle.from_bottom == true`
    - Optionally, set the number of items to jump by, defaults to 1: `function(cmp) return cmp.select_next({ count = 5 }) end`
    - Optionally, control the `auto_insert` property of `completion.list.selection`: `function(cmp) cmp.select_next({ auto_insert = false }) end`
    - Optionally, run when ghost text is visible, instead of only when the menu is visible: `function(cmp) cmp.select_next({ on_ghost_text = true })`
    - Optionally, jump to the item whose specified property differs from the current one: `function(cmp) cmp.select_next({ jump_by = 'source_id' })`
- `insert_prev`: Inserts the previous item (`auto_insert`), cycling to the bottom of the list if at the top, if `completion.list.cycle.from_top == true`. This will trigger completions if none are available, unlike `select_prev` which would fallback to the next keymap in this case.
- `insert_next`: Inserts the next item (`auto_insert`), cycling to the top of the list if at the bottom, if `completion.list.cycle.from_bottom == true`. This will trigger completions if none are available, unlike `select_next` which would fallback to the next keymap in this case.
- `show_documentation`: Shows the documentation for the currently selected item
- `hide_documentation`: Hides the documentation
- `scroll_documentation_up`: Scrolls the documentation up by 4 lines
    - Optionally use `function(cmp) cmp.scroll_documentation_up(4) end` to scroll by a specific number of lines
- `scroll_documentation_down`: Scrolls the documentation down by 4 lines
    - Optionally use `function(cmp) cmp.scroll_documentation_down(4) end` to scroll by a specific number of lines
- `show_signature`: Shows the signature help window
- `hide_signature`: Hides the signature help window
- `scroll_signature_up`: Scrolls the signature help window up by 4 lines
    - Optionally use `function(cmp) cmp.scroll_signature_up(4) end` to scroll by a specific number of lines
- `scroll_signature_down`: Scrolls the signature help window down by 4 lines
    - Optionally use `function(cmp) cmp.scroll_signature_down(4) end` to scroll by a specific number of lines
- `snippet_forward`: Jumps to the next snippet placeholder
- `snippet_backward`: Jumps to the previous snippet placeholder
- `fallback`: Runs the next non-blink keymap, or runs the built-in neovim binding
- `fallback_to_mappings`: Runs the next non-blink keymap (not built-in behavior)


CMDLINE AND TERMINAL ~

See the respective cmdline documentation <../modes/cmdline.md> and terminal
documentation <../modes/term.md> for more information.


PRESETS ~

Set the preset to `'none'` to disable the presets


DEFAULT

>lua
    ['<C-space>'] = { 'show', 'show_documentation', 'hide_documentation' },
    ['<C-e>'] = { 'hide', 'fallback' },
    ['<C-y>'] = { 'select_and_accept', 'fallback' },
    
    ['<Up>'] = { 'select_prev', 'fallback' },
    ['<Down>'] = { 'select_next', 'fallback' },
    ['<C-p>'] = { 'select_prev', 'fallback_to_mappings' },
    ['<C-n>'] = { 'select_next', 'fallback_to_mappings' },
    
    ['<C-b>'] = { 'scroll_documentation_up', 'fallback' },
    ['<C-f>'] = { 'scroll_documentation_down', 'fallback' },
    
    ['<Tab>'] = { 'snippet_forward', 'fallback' },
    ['<S-Tab>'] = { 'snippet_backward', 'fallback' },
    
    ['<C-k>'] = { 'show_signature', 'hide_signature', 'fallback' },
<


CMDLINE

See the cmdline documentation <../modes/cmdline.md>


SUPER-TAB

You may want to set `completion.trigger.show_in_snippet = false` or use
`completion.list.selection.preselect = function(ctx) return not
require('blink.cmp').snippet_active({ direction = 1 }) end`. See more info in:
https://cmp.saghen.dev/configuration/completion.html#list

>lua
    ['<C-space>'] = { 'show', 'show_documentation', 'hide_documentation' },
    ['<C-e>'] = { 'hide', 'fallback' },
    
    ['<Tab>'] = {
      function(cmp)
        if cmp.snippet_active() then return cmp.accept()
        else return cmp.select_and_accept() end
      end,
      'snippet_forward',
      'fallback'
    },
    ['<S-Tab>'] = { 'snippet_backward', 'fallback' },
    
    ['<Up>'] = { 'select_prev', 'fallback' },
    ['<Down>'] = { 'select_next', 'fallback' },
    ['<C-p>'] = { 'select_prev', 'fallback_to_mappings' },
    ['<C-n>'] = { 'select_next', 'fallback_to_mappings' },
    
    ['<C-b>'] = { 'scroll_documentation_up', 'fallback' },
    ['<C-f>'] = { 'scroll_documentation_down', 'fallback' },
    
    ['<C-k>'] = { 'show_signature', 'hide_signature', 'fallback' },
<


ENTER

You may want to set `completion.list.selection.preselect = false`. See more
info in: https://cmp.saghen.dev/configuration/completion.html#list

>lua
    ['<C-space>'] = { 'show', 'show_documentation', 'hide_documentation' },
    ['<C-e>'] = { 'hide', 'fallback' },
    ['<CR>'] = { 'accept', 'fallback' },
    
    ['<Tab>'] = { 'snippet_forward', 'fallback' },
    ['<S-Tab>'] = { 'snippet_backward', 'fallback' },
    
    ['<Up>'] = { 'select_prev', 'fallback' },
    ['<Down>'] = { 'select_next', 'fallback' },
    ['<C-p>'] = { 'select_prev', 'fallback_to_mappings' },
    ['<C-n>'] = { 'select_next', 'fallback_to_mappings' },
    
    ['<C-b>'] = { 'scroll_documentation_up', 'fallback' },
    ['<C-f>'] = { 'scroll_documentation_down', 'fallback' },
    
    ['<C-k>'] = { 'show_signature', 'hide_signature', 'fallback' },
<


SIGNATURE                                         *blink-cmp-config-signature*


Blink supports signature help by manually pressing `<C-k>` (by default) or
automatically triggered when typing trigger characters, defined by the LSP,
such as `(` for `lua`. The menu will be updated when pressing a retrigger
character, such as `,`. Due to it being experimental, this feature is opt-in.

>lua
    signature = { enabled = true }
<



You may want to set `signature.window.show_documentation = false` to only show
the signature, and not the documentation.


KEYMAP ~

See the keymap documentation <../modes/cmdline.md#keymap> for a full list of
commands. By default, the `scroll_signature_up` and `scroll_signature_down`
commands are not bound to any keys. You may bind them like so:

>lua
    keymap = {
      ['<C-u>'] = { 'scroll_signature_up', 'fallback' },
      ['<C-d>'] = { 'scroll_signature_down', 'fallback' },
    
      -- default in all keymap presets
      ['<C-k>'] = { 'show_signature', 'hide_signature', 'fallback' },
    }
<


SNIPPETS                                           *blink-cmp-config-snippets*

Blink uses the `vim.snippet` API by default for expanding and navigating
snippets. The built-in `snippets` source will load friendly-snippets
<https://github.com/rafamadriz/friendly-snippets>, if available, and load any
snippets found at `~/.config/nvim/snippets/`. For use with Luasnip, see the
|blink-cmp-luasnip-section|. For use with mini.snippets, see the
|blink-cmp-mini.snippets-section|. For use with vim-vsnip, see the
|blink-cmp-vim-vsnip-section|.


FRIENDLY SNIPPETS ~

When using the built-in `vim.snippet` snippet engine, friendly-snippets
<https://github.com/rafamadriz/friendly-snippets> will be automatically loaded,
if available (disable with `friendly_snippets = false`). To add snippets from a
framework to a filetype
<https://github.com/rafamadriz/friendly-snippets?tab=readme-ov-file#add-snippets-from-a-framework-to-a-filetype>
use `extended_filetypes`.

>lua
    sources = {
      providers = {
        snippets = {
          opts = {
            friendly_snippets = true, -- default
    
            -- see the list of frameworks in: https://github.com/rafamadriz/friendly-snippets/tree/main/snippets/frameworks
            -- and search for possible languages in: https://github.com/rafamadriz/friendly-snippets/blob/main/package.json
            -- the following is just an example, you should only enable the frameworks that you use
            extended_filetypes = {
              markdown = { 'jekyll' },
              sh = { 'shelldoc' },
              php = { 'phpdoc' },
              cpp = { 'unreal' }
            }
          }
        }
      }
    }
<


CUSTOM SNIPPETS ~

By default, the `snippets` source will check `~/.config/nvim/snippets` for your
custom snippets, but you may add additional folders via
`sources.providers.snippets.opts.search_paths`. Currently, only VSCode style
snippets are supported, but you may look into Luasnip
<https://github.com/L3MON4D3/LuaSnip> if you’d like more advanced
functionality. If you’re coming from snipmate snippets, nadiamoe
<https://github.com/nadiamoe> wrote a small tool for converting them to JSON
<https://github.com/nadiamoe/snipmate-to-json> (here be dragons! original
discussion
<https://github.com/Saghen/blink.cmp/discussions/654#discussioncomment-12083447>)

There’s a great introduction to writing custom snippets in the nvim-scissors
repo
<https://github.com/chrisgrieser/nvim-scissors?tab=readme-ov-file#cookbook--faq>.
Here’s an example, using the linux/mac path for the neovim configuration:

>jsonc
    // ~/.config/nvim/snippets/package.json
    {
      "name": "personal-snippets",
      "contributes": {
        "snippets": [
          { "language": "lua", "path": "./lua.json" }
          { "language": ["typescriptreact", "javascriptreact"], "path": "./react.json" }
          { "language": "all", "path": "./all.json" }
        ]
      }
    }
<

>jsonc
    // ~/.config/nvim/snippets/lua.json
    {
      "foo": {
        "prefix": "foo",
        "body": [
          "local ${1:foo} = ${2:bar}",
          "return ${3:baz}"
        ]
      }
    }
<


LUASNIP ~

>lua
    {
      'saghen/blink.cmp',
      version = '1.*',
      -- `main` is untested, please open a PR if you've confirmed it works as expected
      dependencies = { 'L3MON4D3/LuaSnip', version = 'v2.*' },
      opts = {
        snippets = { preset = 'luasnip' },
        -- ensure you have the `snippets` source (enabled by default)
        sources = {
          default = { 'lsp', 'path', 'snippets', 'buffer' },
        },
      }
    }
<


MINI.SNIPPETS ~

>lua
    {
      'saghen/blink.cmp',
      dependencies = 'echasnovski/mini.snippets',
      opts = {
        snippets = { preset = 'mini_snippets' },
        -- ensure you have the `snippets` source (enabled by default)
        sources = {
          default = { 'lsp', 'path', 'snippets', 'buffer' },
        },
      }
    }
<


VIM-VSNIP ~

>lua
    {
      'saghen/blink.cmp',
      dependencies = {'hrsh7th/vim-vsnip', 'https://codeberg.org/FelipeLema/bink-cmp-vsnip.git'},
      opts = {
        snippets = { preset = 'vsnip' },
        sources = {
          default = { 'lsp', 'path', 'snippets', 'buffer' },
        },
      }
    }
<


DISABLE ALL SNIPPETS ~

>lua
    sources.transform_items = function(_, items)
      return vim.tbl_filter(function(item)
        return item.kind ~= require('blink.cmp.types').CompletionItemKind.Snippet
      end, items)
    end
<

When setting up your capabilities with `lspconfig`, add the following:

>lua
    capabilities = require('blink.cmp').get_lsp_capabilities({
      textDocument = { completion = { completionItem = { snippetSupport = false } } },
    })
<

Some LSPs may ignore the `snippetSupport` field, in which case, you need to set
LSP specific options while setting them up. Some examples:

>lua
    -- If you're using `opts = { ['rust-analyzer'] = { } }` in your lspconfig configuration, simply put these options in there instead
    
    -- For `rust-analyzer`
    lspconfig['rust-analyzer'].setup({
      completion = {
        callable = {
          snippets = 'add_parenthesis'
        }
      }
    })
    
    -- For `lua_ls`
    lspconfig.lua_ls.setup({
      settings = {
        Lua = {
          completion = {
            callSnippet = 'Disable',
            keywordSnippet = 'Disable',
          }
        }
      }
    })
<

Please open a PR if you know of any other LSPs that require special
configuration!


SOURCES                                             *blink-cmp-config-sources*


Blink provides a sources interface, modelled after LSPs, for getting completion
items, trigger characters, documentation and signature help. The `lsp`, `path`,
`snippets`, `luasnip`, `buffer`, and `omni` sources are built-in. You may add
additional |blink-cmp-community-sources| as well. Check out the source
boilerplate <../development/source-boilerplate.md> to learn how to write your
own!


PROVIDERS ~

Sources are configured via the `sources.providers` table, where each `id`
(`key`) must have a `name` and `module` field. The `id` (`key`) may be used in
the `sources.default/per_filetype`, `cmdline.sources`, and `term.sources` to
enable the source.

See the reference <./reference.md#sources> for the default configuration
options.

>lua
    sources = {
      -- `lsp`, `buffer`, `snippets`, `path` and `omni` are built-in
      -- so you don't need to define them in `sources.providers`
      default = { 'lsp', 'buffer', 'snippets', 'path' },
    
      per_filetype = {
        sql = { 'dadbod' },
        -- optionally inherit from the `default` sources
        lua = { inherit_defaults = true, 'lazydev' }
      },
      providers = {
        dadbod = { module = "vim_dadbod_completion.blink" },
        lazydev = { ... }
      }
    }
<


PROVIDER OPTIONS

All of the fields shown below apply to all sources. The `opts` field is passed
to the source directly, and will vary by source.

>lua
    sources.providers.lsp = {
      name = 'LSP',
      module = 'blink.cmp.sources.lsp',
      opts = {}, -- Passed to the source directly, varies by source
    
      --- NOTE: All of these options may be functions to get dynamic behavior
      --- See the type definitions for more information
      enabled = true, -- Whether or not to enable the provider
      async = false, -- Whether we should show the completions before this provider returns, without waiting for it
      timeout_ms = 2000, -- How long to wait for the provider to return before showing completions and treating it as asynchronous
      transform_items = nil, -- Function to transform the items before they're returned
      should_show_items = true, -- Whether or not to show the items
      max_items = nil, -- Maximum number of items to display in the menu
      min_keyword_length = 0, -- Minimum number of characters in the keyword to trigger the provider
      -- If this provider returns 0 items, it will fallback to these providers.
      -- If multiple providers fallback to the same provider, all of the providers must return 0 items for it to fallback
      fallbacks = {},
      score_offset = 0, -- Boost/penalize the score of the items
      override = nil, -- Override the source's functions
    }
<


SHOW BUFFER COMPLETIONS WITH LSP

By default, the buffer source will only show when the LSP source is disabled or
returns no items. You may always show the buffer source via:

>lua
    sources = {
      providers = {
        -- defaults to `{ 'buffer' }`
        lsp = { fallbacks = {} }
      }
    }
<


TERMINAL AND CMDLINE SOURCES ~


You may use `cmdline` and `term` sources via the `cmdline.sources` and
`term.sources` tables. You may see the defaults in the reference
<./reference.md#mode-specific>. There’s no source for shell completions at
the moment, contributions welcome
<https://github.com/Saghen/blink.cmp/issues/1149>!


USING NVIM-CMP SOURCES ~

Blink can use `nvim-cmp` sources through a compatibility layer developed by
stefanboca <https://github.com/stefanboca>: blink.compat
<https://github.com/Saghen/blink.compat>. Please open any issues with
`blink.compat` in that repo


CHECKING STATUS OF SOURCES PROVIDERS ~

The command `:BlinkCmp status` can be used to view which sources providers are
enabled or not enabled.


COMMUNITY SOURCES ~

See blink.compat <https://github.com/Saghen/blink.compat> for using `nvim-cmp`
sources

- lazydev <https://github.com/folke/lazydev.nvim>
- vim-dadbod-completion <https://github.com/kristijanhusak/vim-dadbod-completion>
- blink-ripgrep <https://github.com/mikavilpas/blink-ripgrep.nvim>
- blink-cmp-ripgrep <https://github.com/niuiic/blink-cmp-rg.nvim>
- blink-cmp-ctags <https://github.com/netmute/blink-cmp-ctags>
- blink-copilot <https://github.com/fang2hou/blink-copilot>
- blink-cmp-supermaven <https://github.com/Huijiro/blink-cmp-supermaven>
- blink-cmp-copilot <https://github.com/giuxtaposition/blink-cmp-copilot>
- minuet-ai.nvim <https://github.com/milanglacier/minuet-ai.nvim>
- blink-emoji.nvim <https://github.com/moyiz/blink-emoji.nvim>
- blink-nerdfont.nvim <https://github.com/MahanRahmati/blink-nerdfont.nvim>
- blink-cmp-dictionary <https://github.com/Kaiser-Yang/blink-cmp-dictionary>
- blink-cmp-git <https://github.com/Kaiser-Yang/blink-cmp-git>
- blink-cmp-spell <https://github.com/ribru17/blink-cmp-spell.git>
- blink-cmp-tmux <https://github.com/mgalliou/blink-cmp-tmux>
- blink-cmp-wezterm <https://github.com/junkblocker/blink-cmp-wezterm>
- css-vars.nvim <https://github.com/jdrupal-dev/css-vars.nvim>
- blink-cmp-env <https://github.com/bydlw98/blink-cmp-env>
- blink-cmp-avante <https://github.com/Kaiser-Yang/blink-cmp-avante>
- blink-cmp-conventional-commits <https://github.com/disrupted/blink-cmp-conventional-commits>
- cmp-pandoc-references <https://github.com/jmbuhr/cmp-pandoc-references>
- blink-cmp-im <https://github.com/yehuohan/blink-cmp-im>: Input Method source
- ecolog.nvim <https://github.com/philosofonusus/ecolog.nvim>
- gitmoji.nvim <https://github.com/Dynge/gitmoji.nvim/>: Completion for gitmojis <https://gitmoji.dev/>
- blink-cmp-agda-symbols <https://github.com/4e554c4c/blink-cmp-agda-symbols>: Completion for Agda <https://wiki.portal.chalmers.se/agda/pmwiki.php>
- blink-cmp-latex <https://github.com/erooke/blink-cmp-latex>: Completion for unicode symbols via latex macros
- blink-cmp-npm <https://github.com/alexandre-abrioux/blink-cmp-npm.nvim>: Completion for NPM package names and versions
- blink-cmp-kitty <https://github.com/garyhurtz/blink_cmp_kitty>: Kitty terminal completion source
- blink-cmp-yanky <https://github.com/marcoSven/blink-cmp-yanky>: Completion for yanky.nvim <https://github.com/gbprod/yanky.nvim>
- blink-cmp-register <https://github.com/phanen/blink-cmp-register>
- blink-cmp-sshconfig <https://github.com/bydlw98/blink-cmp-sshconfig>
- blink-cmp-words <https://github.com/archie-judd/blink-cmp-words>: Definitions and synonyms
- blink-cmp-vsnip <https://codeberg.org/FelipeLema/blink-cmp-vsnip>
- blink-cmp-dat-word <https://github.com/xieyonn/blink-cmp-dat-word>: Word completion


REFERENCE                                         *blink-cmp-config-reference*


>lua
    -- Enables keymaps, completions and signature help when true (doesn't apply to cmdline or term)
    --
    -- If the function returns 'force', the default conditions for disabling the plugin will be ignored
    -- Default conditions: (vim.bo.buftype ~= 'prompt' and vim.b.completion ~= false)
    -- Note that the default conditions are ignored when `vim.b.completion` is explicitly set to `true`
    --
    -- Exceptions: vim.bo.filetype == 'dap-repl'
    enabled = function() return true end,
    
    -- See the "keymap" page for more information
    keymap = { preset = 'default' },
<


SNIPPETS ~

>lua
    snippets = {
      -- Function to use when expanding LSP provided snippets
      expand = function(snippet) vim.snippet.expand(snippet) end,
      -- Function to use when checking if a snippet is active
      active = function(filter) return vim.snippet.active(filter) end,
      -- Function to use when jumping between tab stops in a snippet, where direction can be negative or positive
      jump = function(direction) vim.snippet.jump(direction) end,
    }
<


COMPLETION ~


COMPLETION KEYWORD

>lua
    completion.keyword = {
      -- 'prefix' will fuzzy match on the text before the cursor
      -- 'full' will fuzzy match on the text before _and_ after the cursor
      -- example: 'foo_|_bar' will match 'foo_' for 'prefix' and 'foo__bar' for 'full'
      range = 'prefix',
    }
<


COMPLETION TRIGGER

>lua
    completion.trigger = {
      -- When true, will prefetch the completion items when entering insert mode
      prefetch_on_insert = true,
    
      -- When false, will not show the completion window automatically when in a snippet
      show_in_snippet = true,
    
      -- When true, will show completion window after backspacing
      show_on_backspace = false,
    
      -- When true, will show completion window after backspacing into a keyword
      show_on_backspace_in_keyword = false,
    
      -- When true, will show the completion window after accepting a completion and then backspacing into a keyword
      show_on_backspace_after_accept = true,
    
      -- When true, will show the completion window after entering insert mode and backspacing into keyword
      show_on_backspace_after_insert_enter = true,
    
      -- When true, will show the completion window after typing any of alphanumerics, `-` or `_`
      show_on_keyword = true,
    
      -- When true, will show the completion window after typing a trigger character
      show_on_trigger_character = true,
    
      -- When true, will show the completion window after entering insert mode
      show_on_insert = false,
    
      -- LSPs can indicate when to show the completion window via trigger characters
      -- however, some LSPs (e.g. tsserver) return characters that would essentially
      -- always show the window. We block these by default.
      show_on_blocked_trigger_characters = { ' ', '\n', '\t' },
      -- You can also block per filetype with a function:
      -- show_on_blocked_trigger_characters = function(ctx)
      --   if vim.bo.filetype == 'markdown' then return { ' ', '\n', '\t', '.', '/', '(', '[' } end
      --   return { ' ', '\n', '\t' }
      -- end,
    
      -- When both this and show_on_trigger_character are true, will show the completion window
      -- when the cursor comes after a trigger character after accepting an item
      show_on_accept_on_trigger_character = true,
    
      -- When both this and show_on_trigger_character are true, will show the completion window
      -- when the cursor comes after a trigger character when entering insert mode
      show_on_insert_on_trigger_character = true,
    
      -- List of trigger characters (on top of `show_on_blocked_trigger_characters`) that won't trigger
      -- the completion window when the cursor comes after a trigger character when
      -- entering insert mode/accepting an item
      show_on_x_blocked_trigger_characters = { "'", '"', '(' },
      -- or a function, similar to show_on_blocked_trigger_character
    }
<


COMPLETION LIST

>lua
    completion.list = {
      -- Maximum number of items to display
      max_items = 200,
    
      selection = {
        -- When `true`, will automatically select the first item in the completion list
        preselect = true,
        -- preselect = function(ctx) return vim.bo.filetype ~= 'markdown' end,
    
        -- When `true`, inserts the completion item automatically when selecting it
        -- You may want to bind a key to the `cancel` command (default <C-e>) when using this option,
        -- which will both undo the selection and hide the completion menu
        auto_insert = true,
        -- auto_insert = function(ctx) return vim.bo.filetype ~= 'markdown' end
      },
    
      cycle = {
        -- When `true`, calling `select_next` at the _bottom_ of the completion list
        -- will select the _first_ completion item.
        from_bottom = true,
        -- When `true`, calling `select_prev` at the _top_ of the completion list
        -- will select the _last_ completion item.
        from_top = true,
      },
    },
<


COMPLETION ACCEPT

>lua
    completion.accept = {
      -- Write completions to the `.` register
      dot_repeat = true,
      -- Create an undo point when accepting a completion item
      create_undo_point = true,
      -- How long to wait for the LSP to resolve the item with additional information before continuing as-is
      resolve_timeout_ms = 100,
      -- Experimental auto-brackets support
      auto_brackets = {
        -- Whether to auto-insert brackets for functions
        enabled = true,
        -- Default brackets to use for unknown languages
        default_brackets = { '(', ')' },
        -- Overrides the default blocked filetypes
        -- See: https://github.com/Saghen/blink.cmp/blob/main/lua/blink/cmp/completion/brackets/config.lua#L5-L9
        override_brackets_for_filetypes = {},
        -- Synchronously use the kind of the item to determine if brackets should be added
        kind_resolution = {
          enabled = true,
          blocked_filetypes = { 'typescriptreact', 'javascriptreact', 'vue' },
        },
        -- Asynchronously use semantic token to determine if brackets should be added
        semantic_token_resolution = {
          enabled = true,
          blocked_filetypes = { 'java' },
          -- How long to wait for semantic tokens to return before assuming no brackets should be added
          timeout_ms = 400,
        },
      },
    },
<


COMPLETION MENU

>lua
    completion.menu = {
      enabled = true,
      min_width = 15,
      max_height = 10,
      border = nil, -- Defaults to `vim.o.winborder` on nvim 0.11+
      winblend = 0,
      winhighlight = 'Normal:BlinkCmpMenu,FloatBorder:BlinkCmpMenuBorder,CursorLine:BlinkCmpMenuSelection,Search:None',
      -- Keep the cursor X lines away from the top/bottom of the window
      scrolloff = 2,
      -- Note that the gutter will be disabled when border ~= 'none'
      scrollbar = true,
      -- Which directions to show the window,
      -- falling back to the next direction when there's not enough space
      direction_priority = { 's', 'n' },
      -- Can accept a function if you need more control
      -- direction_priority = function()
      --   if condition then return { 'n', 's' } end
      --   return { 's', 'n' }
      -- end,
    
      -- Whether to automatically show the window when new completion items are available
      auto_show = true,
      -- Delay before showing the completion menu
      auto_show_delay_ms = 0,
    
      -- Screen coordinates of the command line
      cmdline_position = function()
        if vim.g.ui_cmdline_pos ~= nil then
          local pos = vim.g.ui_cmdline_pos -- (1, 0)-indexed
          return { pos[1] - 1, pos[2] }
        end
        local height = (vim.o.cmdheight == 0) and 1 or vim.o.cmdheight
        return { vim.o.lines - height, 0 }
      end,
    }
<


COMPLETION MENU DRAW

>lua
    -- Controls how the completion items are rendered on the popup window
    completion.menu.draw = {
      -- Aligns the keyword you've typed to a component in the menu
      align_to = 'label', -- or 'none' to disable, or 'cursor' to align to the cursor
      -- Left and right padding, optionally { left, right } for different padding on each side
      padding = 1,
      -- Gap between columns
      gap = 1,
      -- Priority of the cursorline highlight, setting this to 0 will render it below other highlights
      cursorline_priority = 10000,
      -- Appends an indicator to snippets label
      snippet_indicator = '~',
      -- Use treesitter to highlight the label text for the given list of sources
      treesitter = {},
      -- treesitter = { 'lsp' }
    
      -- Components to render, grouped by column
      columns = { { 'kind_icon' }, { 'label', 'label_description', gap = 1 } },
    
      -- Definitions for possible components to render. Each defines:
      --   ellipsis: whether to add an ellipsis when truncating the text
      --   width: control the min, max and fill behavior of the component
      --   text function: will be called for each item
      --   highlight function: will be called only when the line appears on screen
      components = {
        kind_icon = {
          ellipsis = false,
          text = function(ctx) return ctx.kind_icon .. ctx.icon_gap end,
          -- Set the highlight priority to 20000 to beat the cursorline's default priority of 10000
          highlight = function(ctx) return { { group = ctx.kind_hl, priority = 20000 } } end,
        },
    
        kind = {
          ellipsis = false,
          width = { fill = true },
          text = function(ctx) return ctx.kind end,
          highlight = function(ctx) return ctx.kind_hl end,
        },
    
        label = {
          width = { fill = true, max = 60 },
          text = function(ctx) return ctx.label .. ctx.label_detail end,
          highlight = function(ctx)
            -- label and label details
            local highlights = {
              { 0, #ctx.label, group = ctx.deprecated and 'BlinkCmpLabelDeprecated' or 'BlinkCmpLabel' },
            }
            if ctx.label_detail then
              table.insert(highlights, { #ctx.label, #ctx.label + #ctx.label_detail, group = 'BlinkCmpLabelDetail' })
            end
    
            -- characters matched on the label by the fuzzy matcher
            for _, idx in ipairs(ctx.label_matched_indices) do
              table.insert(highlights, { idx, idx + 1, group = 'BlinkCmpLabelMatch' })
            end
    
            return highlights
          end,
        },
    
        label_description = {
          width = { max = 30 },
          text = function(ctx) return ctx.label_description end,
          highlight = 'BlinkCmpLabelDescription',
        },
    
        source_name = {
          width = { max = 30 },
          text = function(ctx) return ctx.source_name end,
          highlight = 'BlinkCmpSource',
        },
    
        source_id = {
          width = { max = 30 },
          text = function(ctx) return ctx.source_id end,
          highlight = 'BlinkCmpSource',
        },
      },
    },
<


COMPLETION DOCUMENTATION

>lua
    completion.documentation = {
      -- Controls whether the documentation window will automatically show when selecting a completion item
      auto_show = false,
      -- Delay before showing the documentation window
      auto_show_delay_ms = 500,
      -- Delay before updating the documentation window when selecting a new item,
      -- while an existing item is still visible
      update_delay_ms = 50,
      -- Whether to use treesitter highlighting, disable if you run into performance issues
      treesitter_highlighting = true,
      -- Draws the item in the documentation window, by default using an internal treesitter based implementation
      draw = function(opts) opts.default_implementation() end,
      window = {
        min_width = 10,
        max_width = 80,
        max_height = 20,
        border = nil, -- Defaults to `vim.o.winborder` on nvim 0.11+ or 'padded' when not defined/<=0.10
        winblend = 0,
        winhighlight = 'Normal:BlinkCmpDoc,FloatBorder:BlinkCmpDocBorder,EndOfBuffer:BlinkCmpDoc',
        -- Note that the gutter will be disabled when border ~= 'none'
        scrollbar = true,
        -- Which directions to show the documentation window,
        -- for each of the possible menu window directions,
        -- falling back to the next direction when there's not enough space
        direction_priority = {
          menu_north = { 'e', 'w', 'n', 's' },
          menu_south = { 'e', 'w', 's', 'n' },
        },
      },
    }
<


COMPLETION GHOST TEXT

>lua
    -- Displays a preview of the selected item on the current line
    completion.ghost_text = {
      enabled = false,
      -- Show the ghost text when an item has been selected
      show_with_selection = true,
      -- Show the ghost text when no item has been selected, defaulting to the first item
      show_without_selection = false,
      -- Show the ghost text when the menu is open
      show_with_menu = true,
      -- Show the ghost text when the menu is closed
      show_without_menu = true,
    },
<


SIGNATURE ~

>lua
    -- Experimental signature help support
    signature = {
      enabled = false,
      trigger = {
        -- Show the signature help automatically
        enabled = true,
        -- Show the signature help window after typing any of alphanumerics, `-` or `_`
        show_on_keyword = false,
        blocked_trigger_characters = {},
        blocked_retrigger_characters = {},
        -- Show the signature help window after typing a trigger character
        show_on_trigger_character = true,
        -- Show the signature help window when entering insert mode
        show_on_insert = false,
        -- Show the signature help window when the cursor comes after a trigger character when entering insert mode
        show_on_insert_on_trigger_character = true,
      },
      window = {
        min_width = 1,
        max_width = 100,
        max_height = 10,
        border = nil, -- Defaults to `vim.o.winborder` on nvim 0.11+ or 'padded' when not defined/<=0.10
        winblend = 0,
        winhighlight = 'Normal:BlinkCmpSignatureHelp,FloatBorder:BlinkCmpSignatureHelpBorder',
        scrollbar = false, -- Note that the gutter will be disabled when border ~= 'none'
        -- Which directions to show the window,
        -- falling back to the next direction when there's not enough space,
        -- or another window is in the way
        direction_priority = { 'n', 's' },
        -- Can accept a function if you need more control
        -- direction_priority = function()
        --   if condition then return { 'n', 's' } end
        --   return { 's', 'n' }
        -- end,
    
        -- Disable if you run into performance issues
        treesitter_highlighting = true,
        show_documentation = true,
      },
    }
<


FUZZY ~

>lua
    fuzzy = {
      -- Controls which implementation to use for the fuzzy matcher.
      --
      -- 'prefer_rust_with_warning' (Recommended) If available, use the Rust implementation, automatically downloading prebuilt binaries on supported systems. Fallback to the Lua implementation when not available, emitting a warning message.
      -- 'prefer_rust' If available, use the Rust implementation, automatically downloading prebuilt binaries on supported systems. Fallback to the Lua implementation when not available.
      -- 'rust' Always use the Rust implementation, automatically downloading prebuilt binaries on supported systems. Error if not available.
      -- 'lua' Always use the Lua implementation, doesn't download any prebuilt binaries
      --
      -- See the prebuilt_binaries section for controlling the download behavior
      implementation = 'prefer_rust_with_warning',
    
      -- Allows for a number of typos relative to the length of the query
      -- Set this to 0 to match the behavior of fzf
      -- Note, this does not apply when using the Lua implementation.
      max_typos = function(keyword) return math.floor(#keyword / 4) end,
    
      -- Frecency tracks the most recently/frequently used items and boosts the score of the item
      -- Note, this does not apply when using the Lua implementation.
      frecency = {
        -- Whether to enable the frecency feature
        enabled = true,
        -- Location of the frecency database
        path = vim.fn.stdpath('state') .. '/blink/cmp/frecency.dat',
        -- UNSAFE!! When enabled, disables the lock and fsync when writing to the frecency database.
        -- This should only be used on unsupported platforms (e.g. alpine, termux)
        unsafe_no_lock = false,
      },
      use_frecency = true, -- deprecated alias for frecency.enabled, will be removed in v2.0
      use_unsafe_no_lock = false, -- deprecated alias for frecency.unsafe_no_lock, will be removed in v2.0
    
      -- Proximity bonus boosts the score of items matching nearby words
      -- Note, this does not apply when using the Lua implementation.
      use_proximity = true,
    
      -- Controls which sorts to use and in which order, falling back to the next sort if the first one returns nil
      -- You may pass a function instead of a string to customize the sorting
      --
      -- Optionally, set the table of sorts via a function instead: sorts = function() return { 'exact', 'score', 'sort_text' } end
      sorts = {
        -- (optionally) always prioritize exact matches
        -- 'exact',
    
        -- pass a function for custom behavior
        -- function(item_a, item_b)
        --   return item_a.score > item_b.score
        -- end,
    
        'score',
        'sort_text',
      },
    
      prebuilt_binaries = {
        -- Whether or not to automatically download a prebuilt binary from github. If this is set to `false`,
        -- you will need to manually build the fuzzy binary dependencies by running `cargo build --release`
        -- Disabled by default when `fuzzy.implementation = 'lua'`
        download = true,
    
        -- Ignores mismatched version between the built binary and the current git sha, when building locally
        ignore_version_mismatch = false,
    
        -- When downloading a prebuilt binary, force the downloader to resolve this version. If this is unset
        -- then the downloader will attempt to infer the version from the checked out git tag (if any).
        --
        -- Beware that if the fuzzy matcher changes while tracking main then this may result in blink breaking.
        force_version = nil,
    
        -- When downloading a prebuilt binary, force the downloader to use this system triple. If this is unset
        -- then the downloader will attempt to infer the system triple from `jit.os` and `jit.arch`.
        -- Check the latest release for all available system triples
        --
        -- Beware that if the fuzzy matcher changes while tracking main then this may result in blink breaking.
        force_system_triple = nil,
    
        -- Extra arguments that will be passed to curl like { 'curl', ..extra_curl_args, ..built_in_args }
        extra_curl_args = {},
    
        proxy = {
            -- When downloading a prebuilt binary, use the HTTPS_PROXY environment variable
            from_env = true,
    
            -- When downloading a prebuilt binary, use this proxy URL. This will ignore the HTTPS_PROXY environment variable
            url = nil,
        },
      },
    }
<


SOURCES ~

See the |blink-cmp-mode-specific-configurations| for setting sources for
`cmdline` and `term`.

>lua
    sources = {
      -- Static list of providers to enable, or a function to dynamically enable/disable providers based on the context
      default = { 'lsp', 'path', 'snippets', 'buffer' },
    
      -- You may also define providers per filetype
      per_filetype = {
        -- optionally inherit from the `default` sources
        -- lua = { inherit_defaults = true, 'lsp', 'path' },
        -- vim = { inherit_defaults = true, 'cmdline' },
      },
    
      -- Function to use when transforming the items before they're returned for all providers
      -- The default will lower the score for snippets to sort them lower in the list
      transform_items = function(_, items) return items end,
    
      -- Minimum number of characters in the keyword to trigger all providers
      -- May also be `function(ctx: blink.cmp.Context): number`
      min_keyword_length = 0,
    }
<


PROVIDERS

>lua
    -- Please see https://github.com/Saghen/blink.compat for using `nvim-cmp` sources
    sources.providers = {
      lsp = {
        name = 'LSP',
        module = 'blink.cmp.sources.lsp',
        -- You may enable the buffer source, when LSP is available, by setting this to `{}`
        -- You may want to set the score_offset of the buffer source to a lower value, such as -5 in this case
        fallbacks = { 'buffer' },
        opts = { tailwind_color_icon = '██' },
    
        --- These properties apply to !!ALL sources!!
        --- NOTE: All of these options may be functions to get dynamic behavior
        --- See the type definitions for more information
        name = nil, -- Defaults to the id ("lsp" in this case) capitalized when not set
        enabled = true, -- Whether or not to enable the provider
        async = false, -- Whether we should show the completions before this provider returns, without waiting for it
        timeout_ms = 2000, -- How long to wait for the provider to return before showing completions and treating it as asynchronous
        transform_items = nil, -- Function to transform the items before they're returned
        should_show_items = true, -- Whether or not to show the items
        max_items = nil, -- Maximum number of items to display in the menu
        -- Minimum number of characters in the keyword to trigger the provider
        -- May also be a function(ctx: blink.cmp.Context): number
        -- To ignore this property when manually showing the menu, set it like:
        -- min_keyword_length = function(ctx) return ctx.trigger.initial_kind == 'manual' and 0 or 1 end
        min_keyword_length = 0, 
        -- If this provider returns 0 items, it will fallback to these providers.
        -- If multiple providers fallback to the same provider, all of the providers must return 0 items for it to fallback
        fallbacks = {},
        score_offset = 0, -- Boost/penalize the score of the items
        override = nil, -- Override the source's functions
      },
    
      path = {
        module = 'blink.cmp.sources.path',
        score_offset = 3,
        fallbacks = { 'buffer' },
        opts = {
          trailing_slash = true,
          label_trailing_slash = true,
          get_cwd = function(context) return vim.fn.expand(('#%d:p:h'):format(context.bufnr)) end,
          show_hidden_files_by_default = false,
          -- Treat `/path` as starting from the current working directory (cwd) instead of the root of your filesystem
          ignore_root_slash = false,
          -- Maximum number of files/directories to return. This limits memory use and responsiveness for very large folders.
          max_entries = 10000,
        }
      },
    
      snippets = {
        module = 'blink.cmp.sources.snippets',
        score_offset = -1, -- receives a -3 from top level snippets.score_offset
    
        -- For `snippets.preset == 'default'`
        opts = {
          friendly_snippets = true,
          search_paths = { vim.fn.stdpath('config') .. '/snippets' },
          global_snippets = { 'all' },
          extended_filetypes = {},
          filter_snippets = function(filetype, file) return true end,
          get_filetype = function(context)
            return vim.bo.filetype
          end,
          -- Set to '+' to use the system clipboard, or '"' to use the unnamed register
          clipboard_register = nil,
          -- Whether to put the snippet description in the label description
          use_label_description = false,
        }
    
        -- For `snippets.preset == 'luasnip'`
        opts = {
          -- Whether to use show_condition for filtering snippets
          use_show_condition = true,
          -- Whether to show autosnippets in the completion list
          show_autosnippets = true,
          -- Whether to prefer docTrig placeholders over trig when expanding regTrig snippets
          prefer_doc_trig = false,
          -- Whether to put the snippet description in the label description
          use_label_description = false,
        }
    
        -- For `snippets.preset == 'mini_snippets'`
        opts = {
          -- Whether to use a cache for completion items
          use_items_cache = true,
          -- Whether to put the snippet description in the label description
          use_label_description = false,
        }
    
        -- For `snippets.preset == 'vsnip'`
        opts = {}
      },
    
      buffer = {
        module = 'blink.cmp.sources.buffer',
        score_offset = -3,
        opts = {
          -- default to all visible buffers
          get_bufnrs = function()
            return vim
              .iter(vim.api.nvim_list_wins())
              :map(function(win) return vim.api.nvim_win_get_buf(win) end)
              :filter(function(buf) return vim.bo[buf].buftype ~= 'nofile' end)
              :totable()
          end,
          -- buffers when searching with `/` or `?`
          get_search_bufnrs = function() return { vim.api.nvim_get_current_buf() } end,
          -- Maximum total number of characters (in an individual buffer) for which buffer completion runs synchronously. Above this, asynchronous processing is used.
          max_sync_buffer_size = 20000,
          -- Maximum total number of characters (in an individual buffer) for which buffer completion runs asynchronously. Above this, the buffer will be skipped.
          max_async_buffer_size = 200000,
          -- Maximum text size across all buffers (default: 500KB)
          max_total_buffer_size = 500000,
          -- Order in which buffers are retained for completion, up to the max total size limit (see above)
          retention_order = { 'focused', 'visible', 'recency', 'largest' },
          -- Cache words for each buffer which increases memory usage but drastically reduces cpu usage. Memory usage depends on the size of the buffers from `get_bufnrs`. For 100k items, it will use ~20MBs of memory. Invalidated and refreshed whenever the buffer content is modified.
          use_cache = true,
          -- Whether to enable buffer source in substitute (:s), global (:g) and grep commands (:grep, :vimgrep, etc.).
          -- Note: Enabling this option will temporarily disable Neovim's 'inccommand' feature
          -- while editing Ex commands, due to a known redraw issue (see neovim/neovim#9783).
          -- This means you will lose live substitution previews when using :s, :smagic, or :snomagic
          -- while buffer completions are active.
          enable_in_ex_commands = false,
        }
      },
    
      cmdline = {
        module = 'blink.cmp.sources.cmdline',
      },
    
      omni = {
        module = 'blink.cmp.sources.complete_func',
        enabled = function() return vim.bo.omnifunc ~= 'v:lua.vim.lsp.omnifunc' end,
        ---@type blink.cmp.CompleteFuncOpts
        opts = {
            complete_func = function() return vim.bo.omnifunc end,
        },
      },
    }
<


APPEARANCE ~

>lua
    appearance = {
      highlight_ns = vim.api.nvim_create_namespace('blink_cmp'),
      -- Sets the fallback highlight groups to nvim-cmp's highlight groups
      -- Useful for when your theme doesn't support blink.cmp
      -- Will be removed in a future release
      use_nvim_cmp_as_default = false,
      -- Set to 'mono' for 'Nerd Font Mono' or 'normal' for 'Nerd Font'
      -- Adjusts spacing to ensure icons are aligned
      nerd_font_variant = 'mono',
      kind_icons = {
        Text = '󰉿',
        Method = '󰊕',
        Function = '󰊕',
        Constructor = '󰒓',
    
        Field = '󰜢',
        Variable = '󰆦',
        Property = '󰖷',
    
        Class = '󱡠',
        Interface = '󱡠',
        Struct = '󱡠',
        Module = '󰅩',
    
        Unit = '󰪚',
        Value = '󰦨',
        Enum = '󰦨',
        EnumMember = '󰦨',
    
        Keyword = '󰻾',
        Constant = '󰏿',
    
        Snippet = '󱄽',
        Color = '󰏘',
        File = '󰈔',
        Reference = '󰬲',
        Folder = '󰉋',
        Event = '󱐋',
        Operator = '󰪚',
        TypeParameter = '󰬛',
      },
    }
<


MODE SPECIFIC ~

You may set configurations which will override the default configuration,
specifically for that mode. Only properties in the top level config that
support `fun()` may be overridden, as well as `sources` and `keymap`.


CMDLINE

>lua
    cmdline = {
      enabled = true,
      -- use 'inherit' to inherit mappings from top level `keymap` config
      keymap = { preset = 'cmdline' },
      sources = { 'buffer', 'cmdline' },
    
      -- OR explicitly configure per cmd type
      -- This ends up being equivalent to above since the sources disable themselves automatically
      -- when not available. You may override their `enabled` functions via
      -- `sources.providers.cmdline.override.enabled = function() return your_logic end`
    
      -- sources = function()
      --   local type = vim.fn.getcmdtype()
      --   -- Search forward and backward
      --   if type == '/' or type == '?' then return { 'buffer' } end
      --   -- Commands
      --   if type == ':' or type == '@' then return { 'cmdline', 'buffer' } end
      --   return {}
      -- end,
    
      completion = {
        trigger = {
          show_on_blocked_trigger_characters = {},
          show_on_x_blocked_trigger_characters = {},
        },
        list = {
          selection = {
            -- When `true`, will automatically select the first item in the completion list
            preselect = true,
            -- When `true`, inserts the completion item automatically when selecting it
            auto_insert = true,
          },
        },
        -- Whether to automatically show the window when new completion items are available
        -- Default is false for cmdline, true for cmdwin (command-line window)
        menu = { auto_show = function(ctx, _) return ctx.mode == 'cmdwin' end },
        -- Displays a preview of the selected item on the current line
        ghost_text = { enabled = true },
      }
    }
<


TERMINAL


>lua
    term = {
      enabled = false,
      keymap = { preset = 'inherit' }, -- Inherits from top level `keymap` config when not set
      sources = {},
      completion = {
        trigger = {
          show_on_blocked_trigger_characters = {},
          show_on_x_blocked_trigger_characters = nil, -- Inherits from top level `completion.trigger.show_on_blocked_trigger_characters` config when not set
        },
        -- Inherits from top level config options when not set
        list = {
          selection = {
            -- When `true`, will automatically select the first item in the completion list
            preselect = nil,
            -- When `true`, inserts the completion item automatically when selecting it
            auto_insert = nil,
          },
        },
        -- Whether to automatically show the window when new completion items are available
        menu = { auto_show = nil },
        -- Displays a preview of the selected item on the current line
        ghost_text = { enabled = nil },
      }
    }
<


==============================================================================
5. Modes                                                     *blink-cmp-modes*


COMMAND LINE (CMDLINE)                *blink-cmp-modes-command-line-(cmdline)*


By default, cmdline completions are enabled (`cmdline.enabled = true`),
matching the behavior of the built-in `cmdline` completion:

- Menu will not show automatically (`cmdline.completion.menu.auto_show = false`)
- Pressing `<Tab>` will show the completion menu and insert the first item
    - Subsequent `<Tab>`s will select the next item, `<S-Tab>` for previous item
- `<C-n>` for next item, `<C-p>` for previous item
- `<C-y>` accepts the current item
- `<C-e>` cancels the completion
- When noice.nvim <https://github.com/folke/noice.nvim> is detected, ghost text will be shown, see the |blink-cmp-ghost-text| section below

See the reference configuration <../configuration/reference.md#cmdline> for the
complete list of options.


KEYMAP PRESET ~

Set via `cmdline.keymap.preset = 'cmdline'`, which is the default. Set to
`'none'` to disable the preset or `'inherit'` to inherit the mappings from the
top level `keymap`. See the keymap documentation <../configuration/keymap.md>
for more information on defining your own.

>lua
    {
      -- optionally, inherit the mappings from the top level `keymap`
      -- instead of using the neovim defaults
      -- preset = 'inherit',
    
      ['<Tab>'] = { 'show_and_insert_or_accept_single', 'select_next' },
      ['<S-Tab>'] = { 'show_and_insert_or_accept_single', 'select_prev' },
    
      ['<C-space>'] = { 'show', 'fallback' },
    
      ['<C-n>'] = { 'select_next', 'fallback' },
      ['<C-p>'] = { 'select_prev', 'fallback' },
      ['<Right>'] = { 'select_next', 'fallback' },
      ['<Left>'] = { 'select_prev', 'fallback' },
    
      ['<C-y>'] = { 'select_and_accept', 'fallback' },
      ['<C-e>'] = { 'cancel', 'fallback' },
    }
<


GHOST TEXT ~

When noice.nvim <https://github.com/folke/noice.nvim> is detected, ghost text
will be shown, likely similar to your terminal shell completions. Pressing
`<Tab>` will open the menu and insert the first item as per usual.



>lua
    cmdline = { completion = { ghost_text = { enabled = true } } }
<


SHOW MENU AUTOMATICALLY ~

By default, the completion menu will not be shown automatically. You may set
`cmdline.completion.menu.auto_show = true` to have it appear automatically.

>lua
    cmdline = {
      keymap = {
        -- recommended, as the default keymap will only show and select the next item
        ['<Tab>'] = { 'show', 'accept' },
      },
      completion = { menu = { auto_show = true } },
    }
<

However, you may want to only show the menu only when writing commands, and not
when searching or using other input menus.

>lua
    cmdline = {
      keymap = {
        -- recommended, as the default keymap will only show and select the next item
        ['<Tab>'] = { 'show', 'accept' },
      },
      completion = {
        menu = {
          auto_show = function(ctx)
            return vim.fn.getcmdtype() == ':'
            -- enable for inputs as well, with:
            -- or vim.fn.getcmdtype() == '@'
          end,
        },
      }
    }
<


ENTER KEYMAP ~

When using `<Enter>` (`<CR>`) to accept the current item, you may want to
accept the completion item and immediately execute the command. You can achieve
this via the `accept_and_enter` command. However, when writing abbreviations
like `:wq`, with the menu automatically showing, you may end up accidentally
accepting a completion item. Thus, you may disable the completions when the
keyword, for the first argument, is less than 3 characters.

>lua
    cmdline = {
      keymap = {
        ['<Tab>'] = { 'accept' },
        ['<CR>'] = { 'accept_and_enter', 'fallback' },
      },
      -- (optionally) automatically show the menu
      completion = { menu = { auto_show = true } }
    },
    sources = {
      providers = {
        cmdline = {
          min_keyword_length = function(ctx)
            -- when typing a command, only show when the keyword is 3 characters or longer
            if ctx.mode == 'cmdline' and string.find(ctx.line, ' ') == nil then return 3 end
            return 0
          end
        }
      }
    }
<


TERMINAL (TERM)                              *blink-cmp-modes-terminal-(term)*

See the reference configuration <../configuration/reference.md#term> for the
complete list of options.

TODO


==============================================================================
6. Development                                         *blink-cmp-development*


ARCHITECTURE                              *blink-cmp-development-architecture*

The plugin use a 4 stage pipeline: trigger -> sources -> fuzzy -> render 1.
**Trigger:** Controls when to request completion items from the sources and
provides a context downstream with the current query (e.g. `hello.wo|`, the
query would be `wo`) and the treesitter object under the cursor (e.g. for
intelligently enabling/disabling sources). It respects trigger characters
passed by the LSP (or any other source) and includes it in the context for
sending to the LSP. 2. **Sources:** Provides a common interface for and merges
the results of completion, trigger character, resolution of additional
information and cancellation. Some sources are builtin: `LSP`, `buffer`,
`path`, `snippets` 3. **Fuzzy:** Rust <-> Lua FFI which performs both filtering
and sorting of the items - **Filtering:** The fuzzy matching uses
smith-waterman, same as FZF, but implemented in SIMD for ~6x the performance of
FZF (TODO: add benchmarks). Due to the SIMD’s performance, the prefiltering
phase on FZF was dropped to allow for typos. Similar to fzy/fzf, additional
points are given to prefix matches, characters with capitals (to promote
camelCase/PascalCase first char matching) and matches after delimiters (to
promote snake_case first char matching) - **Sorting:** Combines fuzzy matching
score with frecency and proximity bonus. Each completion item may also include
a `score_offset` which will be added to this score to demote certain sources.
The `snippets` source takes advantage of this to avoid taking precedence over
the LSP source. The parameters here still need to be tuned, so please let me
know if you find some magical parameters! 4. **Windows:** Responsible for
placing the menu, documentation and function parameters windows. All of the
rendering can be overridden following a syntax similar to incline.nvim. It uses
the neovim window decoration provider to provide next to no overhead from
highlighting.


LSP SUPPORT TRACKER                *blink-cmp-development-lsp-support-tracker*


COMPLETION ITEMS ~

- ☒ `completionItem/resolve`


CLIENT CAPABILITIES

- ☐ `dynamicRegistration`
- ☒ `CompletionItem`
    - ☒ `snippetSupport`
    - ☐ `commitCharacterSupport`
    - ☒ `documentationFormat`
    - ☒ `deprecatedSupport`
    - ☐ `preselectSupport`
    - ☒ `tagSupport`
    - ☐ `insertReplaceSupport`
    - ☒ `resolveSupport`
    - ☒ `insertTextModeSupport`
    - ☒ `labelDetailsSupport`
- ☒ `completionItemKind`
- ☒ `contextSupport`


SERVER CAPABILITIES

- ☒ `triggerCharacters`
- ☐ `allCommitCharacters`
- ☒ `resolveProvider`
- ☒ `CompletionItem`
    - ☒ `labelDetailsSupport`


REQUEST PARAMS

- ☒ `CompletionContext`
    - ☒ `triggerKind`
    - ☒ `triggerCharacter`


LIST

- ☒ `isIncomplete`
- ☒ `itemDefaults`
    - ☒ `commitCharacters`
    - ☒ `editRange`
    - ☒ `insertTextFormat`
    - ☒ `insertTextMode`
    - ☒ `data`
- ☒ `items`


ITEM

- ☒ `label`
- ☒ `labelDetails`
- ☒ `kind`
- ☒ `tags`
- ☒ `detail`
- ☒ `documentation` <- both string and markup content
- ☒ `deprecated`
- ☐ `preselect`
- ☒ `sortText`
- ☒ `filterText`
- ☒ `insertText`
- ☒ `insertTextFormat` <- regular or snippet
- ☐ `insertTextMode` <- asIs only, not sure we’ll support adjustIndentation
- ☒ `textEdit`
- ☒ `textEditText`
- ☒ `additionalTextEdits` <- known issue where applying the main text edit will cause this to be wrong if the additional text edit comes after since the indices will be offset
- ☐ `commitCharacters`
- ☒ `command`
- ☒ `data` <- Don’t think there’s anything special to do here


SOURCE BOILERPLATE                  *blink-cmp-development-source-boilerplate*

If you’re missing autocomplete, ensure you have lazydev.nvim
<https://github.com/folke/lazydev.nvim> installed. If you plan to publish your
source, please use the format `blink-cmp-your-source` and submit a PR adding it
to the community sources <../configuration/sources#community-sources> so that
others may find it easily. You may also add the `blink-cmp` tag.

Assuming you’ve defined your source in `lua/your-source/init.lua`, you may
add it to blink.cmp like so (note that `init.lua` is used by default by lua
when pointing to a directory):

>lua
    {
      'saghen/blink.cmp',
      opts = {
        sources = {
          default = { 'foo' },
          providers = {
            foo = {
              name = 'Foo',
              module = 'your-source', -- blink.cmp will call `require('your-source').new(...)`
              opts = { some_option = 'some value' }, -- passed to `source.new(opts)`
          }
        }
      }
    }
<

>lua
    --- @module 'blink.cmp'
    --- @class blink.cmp.Source
    local source = {}
    
    -- `opts` table comes from `sources.providers.your_provider.opts`
    -- You may also accept a second argument `config`, to get the full
    -- `sources.providers.your_provider` table
    function source.new(opts)
      vim.validate('your-source.opts.some_option', opts.some_option, { 'string' })
      vim.validate('your-source.opts.optional_option', opts.optional_option, { 'string' }, true)
    
      local self = setmetatable({}, { __index = source })
      self.opts = opts
      return self
    end
    
    -- (Optional) Enable the source in specific contexts only
    function source:enabled() return vim.bo.filetype == 'lua' end
    
    -- (Optional) Non-alphanumeric characters that trigger the source
    function source:get_trigger_characters() return { '.' } end
    
    function source:get_completions(ctx, callback)
      -- ctx (context) contains the current keyword, cursor position, bufnr, etc.
    
      -- You should never filter items based on the keyword, since blink.cmp will
      -- do this for you
    
      -- https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionItem
      --- @type lsp.CompletionItem[]
      local items = {}
      for i = 1, 10 do
        --- @type lsp.CompletionItem
        local item = {
          -- Label of the item in the UI
          label = 'foo',
          -- (Optional) Item kind, where `Function` and `Method` will receive
          -- auto brackets automatically
          kind = require('blink.cmp.types').CompletionItemKind.Text,
    
          -- (Optional) Text to fuzzy match against
          filterText = 'bar',
          -- (Optional) Text to use for sorting. You may use a layout like
          -- 'aaaa', 'aaab', 'aaac', ... to control the order of the items
          sortText = 'baz',
    
          -- Text to be inserted when accepting the item using ONE of:
          --
          -- (Recommended) Control the exact range of text that will be replaced
          textEdit = {
            newText = 'item ' .. i,
            range = {
              -- 0-indexed line and character, end-exclusive
              start = { line = 0, character = 0 },
              ['end'] = { line = 0, character = 0 },
            },
          },
          -- Or get blink.cmp to guess the range to replace for you. Use this only
          -- when inserting *exclusively* alphanumeric characters. Any symbols will
          -- trigger complicated guessing logic in blink.cmp that may not give the
          -- result you're expecting
          -- Note that blink.cmp will use `label` when omitting both `insertText` and `textEdit`
          insertText = 'foo',
          -- May be Snippet or PlainText. Works with both `textEdit` and `insertText`
          -- https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#snippet_syntax
          insertTextFormat = vim.lsp.protocol.InsertTextFormat.PlainText,
    
          -- There are some other fields you may want to explore which are blink.cmp
          -- specific, such as `score_offset` (blink.cmp.CompletionItem)
        }
        table.insert(items, item)
      end
    
      -- The callback _MUST_ be called at least once. The first time it's called,
      -- blink.cmp will show the results in the completion menu. Subsequent calls
      -- will append the results to the menu to support streaming results.
      --
      -- NOTE: blink.cmp will mutate the items you return, so you must vim.deepcopy them
      -- before returning if you want to re-use them in the future (such as for caching)
      callback({
        items = items,
        -- Whether blink.cmp should request items when deleting characters
        -- from the keyword (e.g. "foo|" -> "fo|")
        -- Note that any non-alphanumeric characters will always request
        -- new items (excluding `-` and `_`)
        is_incomplete_backward = false,
        -- Whether blink.cmp should request items when adding characters
        -- to the keyword (e.g. "fo|" -> "foo|")
        -- Note that any non-alphanumeric characters will always request
        -- new items (excluding `-` and `_`)
        is_incomplete_forward = false,
      })
    
      -- (Optional) Return a function which cancels the request
      -- If you have long running requests, it's essential you support cancellation
      return function() end
    end
    
    -- (Optional) Before accepting the item or showing documentation, blink.cmp will call this function
    -- so you may avoid calculating expensive fields (e.g. documentation) for only when they're actually needed
    -- Note only some fields may be resolved lazily. You may check the LSP capabilities for a complete list:
    -- `textDocument.completion.completionItem.resolveSupport`
    -- At the time of writing: 'documentation', 'detail', 'additionalTextEdits', 'command', 'data'
    function source:resolve(item, callback)
      item = vim.deepcopy(item)
    
      -- Shown in the documentation window (<C-space> when menu open by default)
      item.documentation = {
        kind = 'markdown',
        value = '# Foo\n\nBar',
      }
    
      -- Additional edits to make to the document, such as for auto-imports
      item.additionalTextEdits = {
        {
          newText = 'foo',
          range = {
            start = { line = 0, character = 0 },
            ['end'] = { line = 0, character = 0 },
          },
        },
      }
    
      callback(item)
    end
    
    -- (Optional) Called immediately after applying the item's textEdit/insertText
    -- Only useful when you want to customize how items are accepted,
    -- beyond what's possible with `textEdit` and `additionalTextEdits`
    function source:execute(ctx, item, callback, default_implementation)
      -- When you provide an `execute` function, your source must handle the execution
      -- of the item itself, but you may use the default implementation at any time
      default_implementation()
    
      -- The callback _MUST_ be called once
      callback()
    end
    
    return source
<

==============================================================================
7. Links                                                     *blink-cmp-links*

1. *@hrsh7th*: 
2. *@garymjr*: 
3. *@redxtech*: 
4. *@aaditya-sahay*: 
5. *@stefanboca*: 
6. *@lopi-py*: 
7. *@scottmckendry*: 
8. *@balssh*: 
9. *@konradmalik*: 
10. *@abeldekat*: 
11. *@wurli*: 
12. *@mikavilpas*: 
13. *@xzbdmw*: 
14. *@soifou*: 
15. *@FerretDetective*: 
16. *@krovuxdev*: 

Generated by panvimdoc <https://github.com/kdheepak/panvimdoc>

vim:tw=78:ts=8:noet:ft=help:norl:
